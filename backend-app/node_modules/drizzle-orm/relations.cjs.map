{"version":3,"sources":["../src/relations.ts"],"sourcesContent":["import { type AnyTable, getTableUniqueName, IsAlias, OriginalName, Schema, Table } from '~/table.ts';\nimport { Columns } from '~/table.ts';\nimport { aliasedTable } from './alias.ts';\nimport type { CasingCache } from './casing.ts';\nimport { type AnyColumn, Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { DrizzleError } from './errors.ts';\nimport {\n\tand,\n\tasc,\n\tbetween,\n\tdesc,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNotNull,\n\tisNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotIlike,\n\tnotInArray,\n\tnotLike,\n\tor,\n} from './sql/expressions/index.ts';\nimport { Placeholder, SQL, sql, type SQLWrapper, View } from './sql/sql.ts';\nimport type { Assume, DrizzleTypeError, Equal, Simplify, ValueOrArray } from './utils.ts';\n\nexport type FieldValue =\n\t| Column\n\t| SQLWrapper\n\t| SQL.Aliased\n\t| SQL;\n\nexport type FieldSelection = Record<string, FieldValue>;\n\nexport class Relations<\n\tTSchema extends Record<string, unknown> = Record<string, unknown>,\n\tTTables extends Record<string, Table | View> = Record<string, Table | View>,\n\tTConfig extends RelationsBuilderConfig<TTables> = RelationsBuilderConfig<TTables>,\n> {\n\tstatic readonly [entityKind]: string = 'RelationsV2';\n\tdeclare readonly $brand: 'RelationsV2';\n\t/** table DB name -> schema table key */\n\treadonly tableNamesMap: Record<string, string> = {};\n\treadonly tablesConfig: TablesRelationalConfig = {};\n\n\tconstructor(\n\t\treadonly schema: TSchema,\n\t\treadonly tables: TTables,\n\t\treadonly config: TConfig,\n\t) {\n\t\tfor (const [tsName, table] of Object.entries(tables)) {\n\t\t\tif (config[tsName]?.$drizzleTypeError) continue;\n\n\t\t\tconst isTable = is(table, Table);\n\t\t\tconst isView = is(table, View);\n\n\t\t\tif (!(isTable || isView)) continue;\n\n\t\t\tthis.tableNamesMap[getTableUniqueName(table)] = tsName as any;\n\n\t\t\tthis.tablesConfig[tsName] = {\n\t\t\t\ttable,\n\t\t\t\ttsName,\n\t\t\t\tdbName: table[Table.Symbol.Name],\n\t\t\t\tschema: table[Table.Symbol.Schema],\n\t\t\t\tcolumns: table[Table.Symbol.Columns] as FieldSelection,\n\t\t\t\trelations: (config[tsName] || {}) as Record<string, RelationsBuilderEntry<TTables, string>>,\n\t\t\t};\n\t\t}\n\n\t\tfor (const tableConfig of Object.values(this.tablesConfig)) {\n\t\t\tfor (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {\n\t\t\t\tif (!is(relation, Relation)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\trelation.sourceTable = tableConfig.table;\n\t\t\t\trelation.fieldName = relationFieldName;\n\t\t\t}\n\t\t}\n\n\t\tfor (const tableConfig of Object.values(this.tablesConfig)) {\n\t\t\tfor (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {\n\t\t\t\tif (!is(relation, Relation)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst relationPrintName = `relations -> ${tableConfig.tsName}: { ${relationFieldName}: r.${\n\t\t\t\t\tis(relation, One) ? 'one' : 'many'\n\t\t\t\t}.${this.tableNamesMap[getTableUniqueName(relation.targetTable)]}(...) }`;\n\n\t\t\t\tif (typeof relation.alias === 'string' && !relation.alias) {\n\t\t\t\t\tthrow new Error(`${relationPrintName}: \"alias\" cannot be an empty string - omit it if you don't need it`);\n\t\t\t\t}\n\n\t\t\t\tif (relation.sourceColumns?.length === 0) {\n\t\t\t\t\tthrow new Error(`${relationPrintName}: \"from\" cannot be an empty array`);\n\t\t\t\t}\n\n\t\t\t\tif (relation.targetColumns?.length === 0) {\n\t\t\t\t\tthrow new Error(`${relationPrintName}: \"to\" cannot be an empty array`);\n\t\t\t\t}\n\n\t\t\t\tif (relation.sourceColumns && relation.targetColumns) {\n\t\t\t\t\tif (relation.sourceColumns.length !== relation.targetColumns.length && !relation.throughTable) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: \"from\" and \"to\" fields without \"through\" must have the same length`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (relation.through) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\trelation.through.source.length !== relation.sourceColumns.length\n\t\t\t\t\t\t\t|| relation.through.target.length !== relation.targetColumns.length\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`${relationPrintName}: \".through(column)\" must be used either on all columns in \"from\" and \"to\" or not defined on any of them`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const column of relation.through.source) {\n\t\t\t\t\t\t\tif (tables[column._.tableName] !== relation.throughTable) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`${relationPrintName}: \".through(column)\" must be used on the same table by all columns of the relation`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const column of relation.through.target) {\n\t\t\t\t\t\t\tif (tables[column._.tableName] !== relation.throughTable) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`${relationPrintName}: \".through(column)\" must be used on the same table by all columns of the relation`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (relation.sourceColumns || relation.targetColumns) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: relation must have either both \"from\" and \"to\" defined, or none of them`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet reverseRelation: Relation | undefined;\n\t\t\t\tconst targetTableTsName = this.tableNamesMap[getTableUniqueName(relation.targetTable)];\n\t\t\t\tif (!targetTableTsName) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Table \"${getTableUniqueName(relation.targetTable)}\" not found in provided TS schema`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst reverseTableConfig = this.tablesConfig[targetTableTsName];\n\t\t\t\tif (!reverseTableConfig) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and no reverse relations of table \"${targetTableTsName}\" were found\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (relation.alias) {\n\t\t\t\t\tconst reverseRelations = Object.values(reverseTableConfig.relations).filter((it): it is Relation =>\n\t\t\t\t\t\tis(it, Relation) && it.alias === relation.alias && it !== relation\n\t\t\t\t\t);\n\t\t\t\t\tif (reverseRelations.length > 1) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and multiple relations with alias \"${relation.alias}\" found in table \"${targetTableTsName}\": ${\n\t\t\t\t\t\t\t\treverseRelations.map((it) => `\"${it.fieldName}\"`).join(', ')\n\t\t\t\t\t\t\t}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treverseRelation = reverseRelations[0];\n\t\t\t\t\tif (!reverseRelation) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and there is no reverse relation of table \"${targetTableTsName}\" with alias \"${relation.alias}\"`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst reverseRelations = Object.values(reverseTableConfig.relations).filter((it): it is Relation =>\n\t\t\t\t\t\tis(it, Relation) && it.targetTable === relation.sourceTable && !it.alias && it !== relation\n\t\t\t\t\t);\n\t\t\t\t\tif (reverseRelations.length > 1) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and multiple relations between \"${targetTableTsName}\" and \"${\n\t\t\t\t\t\t\t\tthis.tableNamesMap[getTableUniqueName(relation.sourceTable)] ?? getTableUniqueName(relation.sourceTable)\n\t\t\t\t\t\t\t}\" were found.\\nHint: you can specify \"alias\" on both sides of the relation with the same value`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treverseRelation = reverseRelations[0];\n\t\t\t\t\tif (!reverseRelation) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and no reverse relation of table \"${targetTableTsName}\" with target table \"${\n\t\t\t\t\t\t\t\tthis.tableNamesMap[getTableUniqueName(relation.sourceTable)] ?? getTableUniqueName(relation.sourceTable)\n\t\t\t\t\t\t\t}\" was found`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!reverseRelation.sourceColumns || !reverseRelation.targetColumns) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`${relationPrintName}: not enough data provided to build the relation - \"from\"/\"to\" are not defined, and reverse relation \"${targetTableTsName}.${reverseRelation.fieldName}\" does not have \"from\"/\"to\" defined`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\trelation.sourceColumns = reverseRelation.targetColumns;\n\t\t\t\trelation.targetColumns = reverseRelation.sourceColumns;\n\t\t\t\trelation.through = reverseRelation.through\n\t\t\t\t\t? {\n\t\t\t\t\t\tsource: reverseRelation.through.target,\n\t\t\t\t\t\ttarget: reverseRelation.through.source,\n\t\t\t\t\t}\n\t\t\t\t\t: undefined;\n\t\t\t\trelation.throughTable = reverseRelation.throughTable;\n\t\t\t\trelation.isReversed = !relation.where;\n\t\t\t\trelation.where = relation.where ?? reverseRelation.where;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport type EmptyRelations = Relations<Record<string, never>, Record<string, never>, Record<string, never>>;\nexport type AnyRelations = Relations<Record<string, any>, Record<string, any>, Record<string, any>>;\n\nexport abstract class Relation<\n\tTSourceTableName extends string = string,\n\tTTargetTableName extends string = string,\n> {\n\tstatic readonly [entityKind]: string = 'RelationV2';\n\tdeclare readonly $brand: 'RelationV2';\n\n\tfieldName!: string;\n\tsourceColumns!: AnyColumn<{ tableName: TSourceTableName }>[];\n\ttargetColumns!: AnyColumn<{ tableName: TTargetTableName }>[];\n\talias: string | undefined;\n\twhere: AnyTableFilter | undefined;\n\tsourceTable!: AnyTable<{ name: TSourceTableName }> | View<TSourceTableName>;\n\tthrough?: {\n\t\tsource: RelationsBuilderColumnBase[];\n\t\ttarget: RelationsBuilderColumnBase[];\n\t};\n\tthroughTable?: Table | View;\n\tisReversed?: boolean;\n\n\tconstructor(\n\t\treadonly targetTable: AnyTable<{ name: TTargetTableName }> | View<TTargetTableName>,\n\t) {\n\t}\n}\n\nexport class One<\n\tTSourceTableName extends string,\n\tTTargetTableName extends string,\n\tTOptional extends boolean = boolean,\n> extends Relation<TSourceTableName, TTargetTableName> {\n\tstatic override readonly [entityKind]: string = 'OneV2';\n\tdeclare protected $relationBrand: 'OneV2';\n\n\treadonly optional: TOptional;\n\n\tconstructor(\n\t\ttables: Record<string, Table | View>,\n\t\ttargetTable: AnyTable<{ name: TTargetTableName }> | View<TTargetTableName>,\n\t\tconfig: AnyOneConfig | undefined,\n\t) {\n\t\tsuper(targetTable);\n\t\tthis.alias = config?.alias;\n\t\tthis.where = config?.where;\n\t\tif (config?.from) {\n\t\t\tthis.sourceColumns = ((Array.isArray(config.from)\n\t\t\t\t? config.from\n\t\t\t\t: [config.from]) as RelationsBuilderColumnBase[]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! : undefined;\n\n\t\t\t\t\treturn it._.column as AnyColumn<{ tableName: TSourceTableName }>;\n\t\t\t\t});\n\t\t}\n\t\tif (config?.to) {\n\t\t\tthis.targetColumns = (Array.isArray(config.to)\n\t\t\t\t? config.to\n\t\t\t\t: [config.to]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! : undefined;\n\n\t\t\t\t\treturn it._.column as AnyColumn<{ tableName: TTargetTableName }>;\n\t\t\t\t});\n\t\t}\n\n\t\tif (this.throughTable) {\n\t\t\tthis.through = {\n\t\t\t\tsource: (Array.isArray(config?.from) ? config.from : [config!.from]).map((\n\t\t\t\t\tc,\n\t\t\t\t) => c._.through!),\n\t\t\t\ttarget: (Array.isArray(config?.to) ? config.to : [config!.to]).map((c) => c._.through!),\n\t\t\t};\n\t\t}\n\t\tthis.optional = (config?.optional ?? true) as TOptional;\n\t}\n}\n\nexport class Many<\n\tTSourceTableName extends string,\n\tTTargetTableName extends string,\n> extends Relation<TSourceTableName, TTargetTableName> {\n\tstatic override readonly [entityKind]: string = 'ManyV2';\n\tdeclare protected $relationBrand: 'ManyV2';\n\n\tconstructor(\n\t\ttables: Record<string, Table | View>,\n\t\ttargetTable: AnyTable<{ name: TTargetTableName }> | View<TTargetTableName>,\n\t\treadonly config: AnyManyConfig | undefined,\n\t) {\n\t\tsuper(targetTable);\n\t\tthis.alias = config?.alias;\n\t\tthis.where = config?.where;\n\t\tif (config?.from) {\n\t\t\tthis.sourceColumns = ((Array.isArray(config.from)\n\t\t\t\t? config.from\n\t\t\t\t: [config.from]) as RelationsBuilderColumnBase[]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! : undefined;\n\n\t\t\t\t\treturn it._.column as AnyColumn<{ tableName: TSourceTableName }>;\n\t\t\t\t});\n\t\t}\n\t\tif (config?.to) {\n\t\t\tthis.targetColumns = (Array.isArray(config.to)\n\t\t\t\t? config.to\n\t\t\t\t: [config.to]).map((it: RelationsBuilderColumnBase) => {\n\t\t\t\t\tthis.throughTable ??= it._.through ? tables[it._.through._.tableName]! : undefined;\n\n\t\t\t\t\treturn it._.column as AnyColumn<{ tableName: TTargetTableName }>;\n\t\t\t\t});\n\t\t}\n\t\tif (this.throughTable) {\n\t\t\tthis.through = {\n\t\t\t\tsource: (Array.isArray(config?.from) ? config.from : [config!.from]).map((\n\t\t\t\t\tc,\n\t\t\t\t) => c._.through!),\n\t\t\t\ttarget: (Array.isArray(config?.to) ? config.to : [config!.to]).map((c) => c._.through!),\n\t\t\t};\n\t\t}\n\t}\n}\n\nexport abstract class AggregatedField<T = unknown> implements SQLWrapper<T> {\n\tstatic readonly [entityKind]: string = 'AggregatedField';\n\n\tdeclare readonly $brand: 'AggregatedField';\n\n\tdeclare readonly _: {\n\t\treadonly data: T;\n\t};\n\n\tprotected table: Table | View | undefined;\n\n\tonTable(table: Table | View) {\n\t\tthis.table = table;\n\n\t\treturn this;\n\t}\n\n\tabstract getSQL(): SQL<T>;\n}\n\nexport class Count extends AggregatedField<number> {\n\tstatic override readonly [entityKind]: string = 'AggregatedFieldCount';\n\n\tdeclare protected $aggregatedFieldBrand: 'Count';\n\n\tprivate query: SQL<number> | undefined;\n\n\tgetSQL(): SQL<number> {\n\t\tif (!this.query) {\n\t\t\tif (!this.table) throw new Error('Table must be set before building aggregate field');\n\t\t\tthis.query = sql`select count(*) as ${sql.identifier('r')} from ${getTableAsAliasSQL(this.table)}`\n\t\t\t\t.mapWith(Number);\n\t\t}\n\n\t\treturn this.query;\n\t}\n}\n\nexport type ExtractObjectValues<T> = T[keyof T];\n\nexport type ExtractRelationsFromTableExtraConfigSchema<\n\tTConfig extends unknown[],\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TConfig as TConfig[K] extends Relations<any> ? K\n\t\t\t\t: never\n\t\t]: TConfig[K] extends Relations<infer TRelationConfig> ? TRelationConfig\n\t\t\t: never;\n\t}\n>;\n\nexport const operators = {\n\tand,\n\tbetween,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNull,\n\tisNotNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotLike,\n\tnotIlike,\n\tnotInArray,\n\tor,\n\tsql,\n};\n\nexport type Operators = typeof operators;\n\nexport const orderByOperators = {\n\tsql,\n\tasc,\n\tdesc,\n};\n\nexport function getOrderByOperators() {\n\treturn orderByOperators;\n}\n\nexport type OrderByOperators = ReturnType<typeof getOrderByOperators>;\n\nexport type FindTableInRelationalConfig<\n\tTSchema extends TablesRelationalConfig,\n\tTTargetTable extends Table | View,\n\tTTableName extends string = TTargetTable['_']['name'],\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TSchema[K]['tsName'] extends TTableName ? K : never\n\t\t]: TSchema[K];\n\t}\n>;\n\nexport interface SQLOperator {\n\tsql: Operators['sql'];\n}\n\nexport type DBQueryConfig<\n\tTRelationType extends 'one' | 'many' = 'one' | 'many',\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig = TableRelationalConfig,\n\tTIsNested extends boolean = false,\n> =\n\t& (TTableConfig['relations'] extends Record<string, never> ? {}\n\t\t: {\n\t\t\twith?:\n\t\t\t\t| {\n\t\t\t\t\t[K in keyof TTableConfig['relations']]?:\n\t\t\t\t\t\t| boolean\n\t\t\t\t\t\t| (TTableConfig['relations'][K] extends Relation ? DBQueryConfig<\n\t\t\t\t\t\t\t\tTTableConfig['relations'][K] extends One<string, string> ? 'one' : 'many',\n\t\t\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\t\t\tFindTableInRelationalConfig<\n\t\t\t\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\t\t\t\tTTableConfig['relations'][K]['targetTable']\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t: never)\n\t\t\t\t\t\t| undefined;\n\t\t\t\t}\n\t\t\t\t| undefined;\n\t\t})\n\t& {\n\t\tcolumns?:\n\t\t\t| {\n\t\t\t\t[K in keyof TTableConfig['columns']]?: boolean | undefined;\n\t\t\t}\n\t\t\t| undefined;\n\t\twhere?: RelationsFilter<TTableConfig, TSchema> | undefined;\n\t\textras?:\n\t\t\t| Record<\n\t\t\t\tstring,\n\t\t\t\t| SQLWrapper\n\t\t\t\t| ((\n\t\t\t\t\ttable: TTableConfig['table'],\n\t\t\t\t\toperators: SQLOperator,\n\t\t\t\t) => SQLWrapper)\n\t\t\t>\n\t\t\t| undefined;\n\t}\n\t& (`${TRelationType}_${TIsNested}` extends 'one_true' ? {} : {\n\t\torderBy?:\n\t\t\t| {\n\t\t\t\t[K in keyof TTableConfig['columns']]?: 'asc' | 'desc' | undefined;\n\t\t\t}\n\t\t\t| ((\n\t\t\t\ttable: TTableConfig['table'],\n\t\t\t\toperators: OrderByOperators,\n\t\t\t) => ValueOrArray<AnyColumn | SQL>)\n\t\t\t| undefined;\n\t\toffset?: number | Placeholder | undefined;\n\t})\n\t& (TRelationType extends 'many' ? {\n\t\t\tlimit?: number | Placeholder | undefined;\n\t\t}\n\t\t: {});\n\nexport type AnyDBQueryConfig = {\n\tcolumns?:\n\t\t| {\n\t\t\t[K in keyof TableRelationalConfig['columns']]?: boolean | undefined;\n\t\t}\n\t\t| undefined;\n\twhere?: RelationsFilter<TableRelationalConfig, TablesRelationalConfig> | undefined;\n\textras?:\n\t\t| Record<\n\t\t\tstring,\n\t\t\t| SQLWrapper\n\t\t\t| ((\n\t\t\t\ttable: TableRelationalConfig['table'],\n\t\t\t\toperators: SQLOperator,\n\t\t\t) => SQLWrapper)\n\t\t>\n\t\t| undefined;\n\n\twith?:\n\t\t| {\n\t\t\t[K in keyof TableRelationalConfig['relations']]?:\n\t\t\t\t| boolean\n\t\t\t\t| (TableRelationalConfig['relations'][K] extends Relation ? DBQueryConfig<\n\t\t\t\t\t\tTableRelationalConfig['relations'][K] extends One<string, string> ? 'one' : 'many',\n\t\t\t\t\t\tTablesRelationalConfig,\n\t\t\t\t\t\tFindTableInRelationalConfig<\n\t\t\t\t\t\t\tTablesRelationalConfig,\n\t\t\t\t\t\t\tTableRelationalConfig['relations'][K]['targetTable']\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t\t\t: never)\n\t\t\t\t| undefined;\n\t\t}\n\t\t| undefined;\n\torderBy?:\n\t\t| {\n\t\t\t[K in keyof TableRelationalConfig['columns']]?: 'asc' | 'desc' | undefined;\n\t\t}\n\t\t| ((\n\t\t\ttable: TableRelationalConfig['table'],\n\t\t\toperators: OrderByOperators,\n\t\t) => ValueOrArray<AnyColumn | SQL>)\n\t\t| undefined;\n\toffset?: number | Placeholder | undefined;\n\tlimit?: number | Placeholder | undefined;\n};\n\nexport interface TableRelationalConfig {\n\ttable: Table | View;\n\ttsName: string;\n\tdbName: string;\n\tschema: string | undefined;\n\tcolumns: FieldSelection;\n\trelations: Record<string, RelationsBuilderEntry>;\n}\n\nexport type TablesRelationalConfig = Record<string, TableRelationalConfig>;\n\nexport interface RelationalSchemaConfig<\n\tTTablesConfig extends TablesRelationalConfig,\n> {\n\ttables: Record<string, Table>;\n\ttablesConfig: TTablesConfig;\n\ttableNamesMap: Record<string, string>;\n}\n\ntype NonUndefinedRecord<TRecord extends Record<string, any>> = {\n\t[K in keyof TRecord as K extends undefined ? never : K]: TRecord[K];\n};\n\nexport type ExtractTablesWithRelations<\n\tTRelations extends Relations,\n\tTTables extends Record<string, Table | View> = TRelations['tables'],\n> = {\n\t[K in keyof TTables]: {\n\t\ttable: TTables[K];\n\t\ttsName: K & string;\n\t\tdbName: TTables[K]['_']['name'];\n\t\tcolumns: TTables[K] extends Table ? TTables[K]['_']['columns'] : Assume<TTables[K], View>['_']['selectedFields'];\n\t\trelations: K extends keyof TRelations['config']\n\t\t\t? TRelations['config'][K] extends Record<string, any> ? NonUndefinedRecord<TRelations['config'][K]>\n\t\t\t: Record<string, never>\n\t\t\t: Record<string, never>;\n\t\t// Views don't have schema on type-level, TBD\n\t\tschema: TTables[K] extends Table ? TTables[K]['_']['schema'] : string | undefined;\n\t};\n};\n\nexport type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R\n\t: T;\n\nexport type BuildRelationResult<\n\tTConfig extends TablesRelationalConfig,\n\tTInclude,\n\tTRelations extends Record<string, RelationsBuilderEntry>,\n> = {\n\t[\n\t\tK in\n\t\t\t& TruthyKeysOnly<TInclude>\n\t\t\t& keyof TRelations\n\t]: TRelations[K] extends infer TRel extends Relation ? BuildQueryResult<\n\t\t\tTConfig,\n\t\t\tFindTableInRelationalConfig<TConfig, TRel['targetTable']>,\n\t\t\tAssume<TInclude[K], true | Record<string, unknown>>\n\t\t> extends infer TResult ? TRel extends One<string, string> ?\n\t\t\t\t\t| TResult\n\t\t\t\t\t| (Equal<TRel['optional'], true> extends true ? null\n\t\t\t\t\t\t: TInclude[K] extends Record<string, unknown> ? TInclude[K]['where'] extends Record<string, any> ? null\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t: never)\n\t\t\t: TResult[]\n\t\t: never\n\t\t: TRelations[K] extends AggregatedField<infer TData> ? TData\n\t\t: never;\n};\n\nexport type NonUndefinedKeysOnly<T> =\n\t& ExtractObjectValues<\n\t\t{\n\t\t\t[K in keyof T as T[K] extends undefined ? never : K]: K;\n\t\t}\n\t>\n\t& keyof T;\n\nexport type TruthyKeysOnly<T> =\n\t& ExtractObjectValues<\n\t\t{\n\t\t\t[K in keyof T as T[K] extends undefined | false ? never : K]: K;\n\t\t}\n\t>\n\t& keyof T;\n\nexport type InferRelationalQueryTableResult<\n\tTTable extends Table | View,\n\tTRawSelection extends Record<string, unknown>,\n\tTSelectedFields extends Record<string, unknown> | 'Full' = 'Full',\n\tTFilteredSelection extends Record<string, unknown> = TSelectedFields extends 'Full' ? TRawSelection : {\n\t\t[\n\t\t\tK in Equal<\n\t\t\t\tExclude<\n\t\t\t\t\tTSelectedFields[\n\t\t\t\t\t\t& keyof TSelectedFields\n\t\t\t\t\t\t& keyof TRawSelection\n\t\t\t\t\t],\n\t\t\t\t\tundefined\n\t\t\t\t>,\n\t\t\t\tfalse\n\t\t\t> extends true ? Exclude<\n\t\t\t\t\tkeyof TRawSelection,\n\t\t\t\t\tNonUndefinedKeysOnly<TSelectedFields>\n\t\t\t\t>\n\t\t\t\t:\n\t\t\t\t\t& {\n\t\t\t\t\t\t[K in keyof TSelectedFields]: Equal<\n\t\t\t\t\t\t\tTSelectedFields[K],\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t> extends true ? K\n\t\t\t\t\t\t\t: never;\n\t\t\t\t\t}[keyof TSelectedFields]\n\t\t\t\t\t& keyof TRawSelection\n\t\t]: TRawSelection[K];\n\t},\n> = {\n\t[K in keyof TFilteredSelection]: TTable['$inferSelect'][Assume<K, keyof TTable['$inferSelect']>];\n};\n\nexport type BuildQueryResult<\n\tTSchema extends TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig,\n\tTFullSelection extends true | Record<string, unknown>,\n> = Equal<TFullSelection, true> extends true\n\t? Simplify<InferRelationalQueryTableResult<TTableConfig['table'], TTableConfig['columns']>>\n\t: TFullSelection extends Record<string, unknown> ? Simplify<\n\t\t\t& (InferRelationalQueryTableResult<\n\t\t\t\tTTableConfig['table'],\n\t\t\t\tTTableConfig['columns'],\n\t\t\t\tTFullSelection['columns'] extends Record<string, unknown> ? TFullSelection['columns'] : 'Full'\n\t\t\t>)\n\t\t\t& (TFullSelection['extras'] extends Record<string, SQLWrapper | ((...args: any[]) => SQLWrapper)> ? {\n\t\t\t\t\t[\n\t\t\t\t\t\tK in NonUndefinedKeysOnly<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>\n\t\t\t\t\t\t>\n\t\t\t\t\t]: ReturnType<\n\t\t\t\t\t\tAssume<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras'][K]>,\n\t\t\t\t\t\t\tSQLWrapper\n\t\t\t\t\t\t>['getSQL']\n\t\t\t\t\t>['_']['type'];\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t\t& (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<\n\t\t\t\t\tTSchema,\n\t\t\t\t\tTFullSelection['with'],\n\t\t\t\t\tTTableConfig['relations']\n\t\t\t\t>\n\t\t\t\t: {})\n\t\t>\n\t: never;\n\nexport interface NormalizedRelation {\n\tfields: AnyColumn[];\n\treferences: AnyColumn[];\n}\n\nexport interface BuildRelationalQueryResult {\n\tselection: {\n\t\tkey: string;\n\t\tfield: Column | Table | SQL | SQL.Aliased | SQLWrapper | AggregatedField;\n\t\tisArray?: boolean;\n\t\tselection?: BuildRelationalQueryResult['selection'];\n\t\tisOptional?: boolean;\n\t}[];\n\tsql: SQL;\n}\n\nexport function mapRelationalRow(\n\trow: Record<string, unknown>,\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n\t/** Needed for SQLite as it returns JSON values as strings */\n\tparseJson: boolean = false,\n\tpath?: string,\n): Record<string, unknown> {\n\tfor (\n\t\tconst selectionItem of buildQueryResultSelection\n\t) {\n\t\tif (selectionItem.selection) {\n\t\t\tconst currentPath = `${path ? `${path}.` : ''}${selectionItem.key}`;\n\n\t\t\tif (row[selectionItem.key] === null) continue;\n\n\t\t\tif (parseJson) row[selectionItem.key] = JSON.parse(row[selectionItem.key] as string);\n\n\t\t\tif (selectionItem.isArray) {\n\t\t\t\tfor (const item of (row[selectionItem.key] as Array<Record<string, unknown>>)) {\n\t\t\t\t\tmapRelationalRow(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\tselectionItem.selection!,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tcurrentPath,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmapRelationalRow(\n\t\t\t\trow[selectionItem.key] as Record<string, unknown>,\n\t\t\t\tselectionItem.selection!,\n\t\t\t\tmapColumnValue,\n\t\t\t\tfalse,\n\t\t\t\tcurrentPath,\n\t\t\t);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst field = selectionItem.field!;\n\t\tconst value = mapColumnValue(row[selectionItem.key]);\n\t\tif (value === null) continue;\n\n\t\tlet decoder;\n\t\tif (is(field, Column)) {\n\t\t\tdecoder = field;\n\t\t} else if (is(field, SQL)) {\n\t\t\tdecoder = field.decoder;\n\t\t} else if (is(field, SQL.Aliased)) {\n\t\t\tdecoder = field.sql.decoder;\n\t\t} else {\n\t\t\tdecoder = field.getSQL().decoder;\n\t\t}\n\t\trow[selectionItem.key] = decoder.mapFromDriverValue(value);\n\t}\n\n\treturn row;\n}\n\nexport class RelationsBuilderTable<TTableName extends string = string> {\n\tstatic readonly [entityKind]: string = 'RelationsBuilderTable';\n\n\treadonly _: {\n\t\treadonly name: TTableName;\n\t\treadonly table: AnyTable<{ name: TTableName }> | View<TTableName>;\n\t};\n\n\tconstructor(table: AnyTable<{ name: TTableName }> | View<TTableName>, key: string) {\n\t\tthis._ = {\n\t\t\tname: key as TTableName,\n\t\t\ttable,\n\t\t};\n\t}\n}\n\nexport interface RelationsBuilderColumnConfig<\n\tTTableName extends string = string,\n\tTData = unknown,\n> {\n\treadonly tableName: TTableName;\n\treadonly data: TData;\n\treadonly column: AnyColumn<{ tableName: TTableName }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>;\n\treadonly through?: RelationsBuilderColumnBase;\n\treadonly key: string;\n}\n\nexport type RelationsBuilderColumnBase<\n\tTTableName extends string = string,\n\tTData = unknown,\n> = {\n\t_: RelationsBuilderColumnConfig<TTableName, TData>;\n};\n\nexport class RelationsBuilderColumn<\n\tTTableName extends string = string,\n\tTData = unknown,\n> implements RelationsBuilderColumnBase<TTableName, TData> {\n\tstatic readonly [entityKind]: string = 'RelationsBuilderColumn';\n\n\treadonly _: {\n\t\treadonly tableName: TTableName;\n\t\treadonly data: TData;\n\t\treadonly column: AnyColumn<{ tableName: TTableName }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>;\n\t\treadonly key: string;\n\t};\n\n\tconstructor(\n\t\tcolumn: AnyColumn<{ tableName: TTableName }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>,\n\t\ttableName: TTableName,\n\t\tkey: string,\n\t) {\n\t\tthis._ = {\n\t\t\ttableName: tableName,\n\t\t\tdata: undefined as TData,\n\t\t\tcolumn,\n\t\t\tkey,\n\t\t};\n\t}\n\n\tthrough(column: RelationsBuilderColumn): RelationsBuilderJunctionColumn<TTableName, TData> {\n\t\treturn new RelationsBuilderJunctionColumn(\n\t\t\tthis._.column,\n\t\t\tthis._.tableName,\n\t\t\tthis._.key,\n\t\t\tcolumn,\n\t\t);\n\t}\n}\n\nexport class RelationsBuilderJunctionColumn<\n\tTTableName extends string = string,\n\tTData = unknown,\n> implements RelationsBuilderColumnBase<TTableName, TData> {\n\tstatic readonly [entityKind]: string = 'RelationsBuilderColumn';\n\n\treadonly _: {\n\t\treadonly tableName: TTableName;\n\t\treadonly data: TData;\n\t\treadonly column: AnyColumn<{ tableName: TTableName }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>;\n\t\treadonly through: RelationsBuilderColumnBase;\n\t\treadonly key: string;\n\t};\n\n\tconstructor(\n\t\tcolumn: AnyColumn<{ tableName: TTableName }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>,\n\t\ttableName: TTableName,\n\t\tkey: string,\n\t\tthrough: RelationsBuilderColumnBase,\n\t) {\n\t\tthis._ = {\n\t\t\ttableName: tableName,\n\t\t\tdata: undefined as TData,\n\t\t\tcolumn,\n\t\t\tthrough,\n\t\t\tkey,\n\t\t};\n\t}\n}\n\nexport interface RelationFieldsFilterInternals<T> {\n\teq?: T | Placeholder | undefined;\n\tne?: T | Placeholder | undefined;\n\tgt?: T | Placeholder | undefined;\n\tgte?: T | Placeholder | undefined;\n\tlt?: T | Placeholder | undefined;\n\tlte?: T | Placeholder | undefined;\n\tin?: (T | Placeholder)[] | Placeholder | undefined;\n\tnotIn?: (T | Placeholder)[] | Placeholder | undefined;\n\tlike?: string | Placeholder | undefined;\n\tilike?: string | Placeholder | undefined;\n\tnotLike?: string | Placeholder | undefined;\n\tnotIlike?: string | Placeholder | undefined;\n\tisNull?: true | undefined;\n\tisNotNull?: true | undefined;\n\tNOT?: RelationsFieldFilter<T> | undefined;\n\tOR?: RelationsFieldFilter<T>[] | undefined;\n\tAND?: RelationsFieldFilter<T>[] | undefined;\n}\n\nexport type RelationsFieldFilter<T = unknown> =\n\t| RelationFieldsFilterInternals<T>\n\t| (\n\t\tunknown extends T ? never : T extends object ? never : T\n\t)\n\t| Placeholder;\n\nexport interface RelationsFilterCommons<\n\tTTable extends TableRelationalConfig = TableRelationalConfig,\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n> {\n\tOR?: RelationsFilter<TTable, TSchema>[] | undefined;\n\tNOT?: RelationsFilter<TTable, TSchema> | undefined;\n\tAND?: RelationsFilter<TTable, TSchema>[] | undefined;\n\tRAW?:\n\t\t| SQLWrapper\n\t\t| ((\n\t\t\ttable: TTable['table'],\n\t\t\toperators: Operators,\n\t\t) => SQL)\n\t\t| undefined;\n}\n\nexport type RelationsFilter<\n\tTTable extends TableRelationalConfig,\n\tTSchema extends TablesRelationalConfig,\n\tTRelations extends Record<string, Relation> = TTable['relations'],\n\tTColumns extends FieldSelection = TTable['columns'],\n> = TTable['relations'] extends Record<string, never> ? TableFilter<TTable['table']>\n\t:\n\t\t& {\n\t\t\t[K in keyof TColumns]?:\n\t\t\t\t| (TColumns[K] extends Column ? RelationsFieldFilter<TColumns[K]['_']['data']>\n\t\t\t\t\t: RelationsFieldFilter<unknown>)\n\t\t\t\t| undefined;\n\t\t}\n\t\t& {\n\t\t\t[K in keyof TRelations]?:\n\t\t\t\t| boolean\n\t\t\t\t| RelationsFilter<FindTableInRelationalConfig<TSchema, TRelations[K]['targetTable']>, TSchema>\n\t\t\t\t| undefined;\n\t\t}\n\t\t& RelationsFilterCommons<TTable, TSchema>;\n\nexport interface TableFilterCommons<\n\tTTable extends Table | View = Table | View,\n\tTColumns extends FieldSelection = TTable extends View ? Assume<TTable['_']['selectedFields'], FieldSelection>\n\t\t: Assume<TTable, Table>['_']['columns'],\n> {\n\tOR?: TableFilter<TTable, TColumns>[] | undefined;\n\tNOT?: TableFilter<TTable, TColumns> | undefined;\n\tAND?: TableFilter<TTable, TColumns>[] | undefined;\n\tRAW?:\n\t\t| SQLWrapper\n\t\t| ((\n\t\t\ttable: TTable,\n\t\t\toperators: Operators,\n\t\t) => SQL)\n\t\t| undefined;\n}\n\nexport type TableFilter<\n\tTTable extends Table | View = Table | View,\n\tTColumns extends FieldSelection = TTable extends View ? Assume<TTable['_']['selectedFields'], FieldSelection>\n\t\t: Assume<TTable, Table>['_']['columns'],\n> =\n\t& {\n\t\t[K in keyof TColumns as K extends keyof TableFilterCommons ? never : K]?: TColumns[K] extends Column\n\t\t\t? RelationsFieldFilter<TColumns[K]['_']['data']>\n\t\t\t: RelationsFieldFilter<unknown>;\n\t}\n\t& TableFilterCommons<TTable, TColumns>;\n\nexport type AnyRelationsFilter = RelationsFilter<\n\tTableRelationalConfig,\n\tTablesRelationalConfig,\n\tRecord<string, Relation>,\n\tFieldSelection\n>;\n\nexport type AnyTableFilter = TableFilter<\n\tTable | View,\n\tFieldSelection\n>;\n\nexport interface OneConfig<\n\tTSchema extends Record<string, Table | View>,\n\tTSourceColumns extends\n\t\t| Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]>\n\t\t| Readonly<RelationsBuilderColumnBase>,\n\tTTargetTableName extends string,\n\tTOptional extends boolean,\n> {\n\tfrom?: TSourceColumns;\n\tto?: TSourceColumns extends\n\t\tRelationsBuilderJunctionColumn | [RelationsBuilderJunctionColumn, ...RelationsBuilderJunctionColumn[]]\n\t\t? RelationsBuilderJunctionColumn<TTargetTableName> | [\n\t\t\tRelationsBuilderJunctionColumn<TTargetTableName>,\n\t\t\t...RelationsBuilderJunctionColumn<TTargetTableName>[],\n\t\t]\n\t\t: TSourceColumns extends [RelationsBuilderColumn]\n\t\t\t? RelationsBuilderColumn<TTargetTableName> | [RelationsBuilderColumn<TTargetTableName>]\n\t\t: TSourceColumns extends [RelationsBuilderColumn, ...RelationsBuilderColumn[]]\n\t\t\t? { [K in keyof TSourceColumns]: RelationsBuilderColumn<TTargetTableName> }\n\t\t: RelationsBuilderColumn<TTargetTableName>;\n\twhere?: TableFilter<TSchema[TTargetTableName]>;\n\toptional?: TOptional;\n\talias?: string;\n}\n\nexport type AnyOneConfig = OneConfig<\n\tRecord<string, Table | View>,\n\tReadonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]] | RelationsBuilderColumnBase<string, unknown>>,\n\tstring,\n\tboolean\n>;\n\nexport interface ManyConfig<\n\tTSchema extends Record<string, Table | View>,\n\tTSourceColumns extends\n\t\t| Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]>\n\t\t| Readonly<RelationsBuilderColumnBase>,\n\tTTargetTableName extends string,\n> {\n\tfrom?: TSourceColumns;\n\tto?: TSourceColumns extends\n\t\tRelationsBuilderJunctionColumn | [RelationsBuilderJunctionColumn, ...RelationsBuilderJunctionColumn[]]\n\t\t? RelationsBuilderJunctionColumn<TTargetTableName> | [\n\t\t\tRelationsBuilderJunctionColumn<TTargetTableName>,\n\t\t\t...RelationsBuilderJunctionColumn<TTargetTableName>[],\n\t\t]\n\t\t: TSourceColumns extends [RelationsBuilderColumn]\n\t\t\t? RelationsBuilderColumn<TTargetTableName> | [RelationsBuilderColumn<TTargetTableName>]\n\t\t: TSourceColumns extends [RelationsBuilderColumn, ...RelationsBuilderColumn[]]\n\t\t\t? { [K in keyof TSourceColumns]: RelationsBuilderColumn<TTargetTableName> }\n\t\t: RelationsBuilderColumn<TTargetTableName>;\n\twhere?: TableFilter<TSchema[TTargetTableName]>;\n\talias?: string;\n}\n\nexport type AnyManyConfig = ManyConfig<\n\tRecord<string, Table | View>,\n\tReadonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]> | Readonly<RelationsBuilderColumnBase>,\n\tstring\n>;\n\nexport interface OneFn<\n\tTTables extends Record<string, Table | View>,\n\tTTargetTableName extends string,\n> {\n\t<\n\t\t// \"any\" default value is required for cases where config is not provided, to satisfy the source table name constraint\n\t\tTSourceColumns extends\n\t\t\t| Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]>\n\t\t\t| RelationsBuilderColumnBase = any,\n\t\tTOptional extends boolean = true,\n\t>(\n\t\tconfig?: OneConfig<TTables, TSourceColumns, TTargetTableName, TOptional>,\n\t): One<\n\t\tTSourceColumns extends [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]\n\t\t\t? TSourceColumns[number]['_']['tableName']\n\t\t\t: Assume<TSourceColumns, RelationsBuilderColumnBase>['_']['tableName'],\n\t\tTTargetTableName,\n\t\tTOptional\n\t>;\n}\n\nexport interface ManyFn<\n\tTTables extends Record<string, Table | View>,\n\tTTargetTableName extends string,\n> {\n\t<\n\t\t// \"any\" default value is required for cases where config is not provided, to satisfy the source table name constraint\n\t\tTSourceColumns extends\n\t\t\t| Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]>\n\t\t\t| RelationsBuilderColumnBase = any,\n\t>(\n\t\tconfig?: ManyConfig<TTables, TSourceColumns, TTargetTableName>,\n\t): Many<\n\t\tTSourceColumns extends [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]\n\t\t\t? TSourceColumns[number]['_']['tableName']\n\t\t\t: Assume<TSourceColumns, RelationsBuilderColumnBase>['_']['tableName'],\n\t\tTTargetTableName\n\t>;\n}\n\nexport class RelationsHelperStatic<TTables extends Record<string, Table | View>> {\n\tstatic readonly [entityKind]: string = 'RelationsHelperStatic';\n\tdeclare readonly $brand: 'RelationsHelperStatic';\n\n\treadonly _: {\n\t\treadonly tables: TTables;\n\t};\n\n\tconstructor(tables: TTables) {\n\t\tthis._ = {\n\t\t\ttables,\n\t\t};\n\n\t\tconst one: Record<string, OneFn<TTables, string>> = {};\n\t\tconst many: Record<string, ManyFn<TTables, string>> = {};\n\n\t\tfor (const [tableName, table] of Object.entries(tables)) {\n\t\t\tone[tableName] = (config) => {\n\t\t\t\treturn new One(tables, table, config as AnyOneConfig);\n\t\t\t};\n\n\t\t\tmany[tableName] = (config) => {\n\t\t\t\treturn new Many(tables, table, config as AnyManyConfig);\n\t\t\t};\n\t\t}\n\n\t\tthis.one = one as this['one'];\n\t\tthis.many = many as this['many'];\n\t}\n\n\tone: {\n\t\t[K in keyof TTables]: OneFn<TTables, K & string>;\n\t};\n\n\tmany: {\n\t\t[K in keyof TTables]: ManyFn<TTables, K & string>;\n\t};\n\n\t/** @internal - to be reworked */\n\taggs = {\n\t\tcount(): Count {\n\t\t\treturn new Count();\n\t\t},\n\t};\n}\n\nexport type RelationsBuilder<TSchema extends Record<string, Table | View>> =\n\t& {\n\t\t[TTableName in keyof TSchema & string]: TSchema[TTableName] extends Table | View<string, boolean, FieldSelection>\n\t\t\t? (\n\t\t\t\t& {\n\t\t\t\t\t[\n\t\t\t\t\t\tTColumnName in keyof (TSchema[TTableName] extends Table ? TSchema[TTableName]['_']['columns']\n\t\t\t\t\t\t\t: Assume<TSchema[TTableName], View>['_']['selectedFields'])\n\t\t\t\t\t]: RelationsBuilderColumn<\n\t\t\t\t\t\tTTableName,\n\t\t\t\t\t\t(TSchema[TTableName] extends Table ? TSchema[TTableName]['_']['columns']\n\t\t\t\t\t\t\t: Assume<Assume<TSchema[TTableName], View>['_']['selectedFields'], FieldSelection>)[TColumnName] extends\n\t\t\t\t\t\t\tinfer Field ? Field extends Column ? Field['_']['data']\n\t\t\t\t\t\t\t: Field extends SQLWrapper<infer Data> | SQL<infer Data> | SQL.Aliased<infer Data> ? Data\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t\t\t: never\n\t\t\t\t\t>;\n\t\t\t\t}\n\t\t\t\t& RelationsBuilderTable<TTableName>\n\t\t\t)\n\t\t\t: DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;\n\t}\n\t& RelationsHelperStatic<TSchema>;\n\nexport type RelationsBuilderConfig<TTables extends Record<string, Table | View>> = {\n\t[TTableName in keyof TTables & string]?: TTables[TTableName] extends Table | View<string, boolean, FieldSelection>\n\t\t? Record<string, RelationsBuilderEntry<TTables, TTableName>>\n\t\t: DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;\n};\n\nexport type RelationsBuilderEntry<\n\tTTables extends Record<string, Table | View> = Record<string, Table | View>,\n\tTSourceTableName extends string = string,\n> = Relation<TSourceTableName, keyof TTables & string>;\n\nexport type ExtractTablesFromSchema<TSchema extends Record<string, unknown>> = {\n\t[K in keyof TSchema as TSchema[K] extends Table | View ? K : never]: TSchema[K] extends Table | View ? TSchema[K]\n\t\t: never;\n};\n\nexport function createRelationsHelper<\n\tTSchema extends Record<string, unknown>,\n\tTTables extends Record<string, Table | View>,\n>(schema: TSchema): RelationsBuilder<TTables> {\n\tconst schemaTables = Object.fromEntries(\n\t\tObject.entries(schema).filter((e): e is [typeof e[0], Table | View] => is(e[1], Table) || is(e[1], View)),\n\t);\n\tconst helperStatic = new RelationsHelperStatic(schemaTables);\n\tconst tables = Object.entries(schema).reduce<Record<string, RelationsBuilderTable>>((acc, [tKey, value]) => {\n\t\tif (is(value, Table) || is(value, View)) {\n\t\t\tconst rTable = new RelationsBuilderTable(value, tKey);\n\t\t\tconst columns = Object.entries(value[Columns]).reduce<\n\t\t\t\tRecord<string, RelationsBuilderColumnBase>\n\t\t\t>(\n\t\t\t\t(acc, [cKey, column]) => {\n\t\t\t\t\tconst rbColumn = new RelationsBuilderColumn(column as Column, tKey, cKey);\n\t\t\t\t\tacc[cKey] = rbColumn;\n\t\t\t\t\treturn acc;\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t);\n\t\t\tacc[tKey] = Object.assign(rTable, columns);\n\t\t}\n\t\treturn acc;\n\t}, {});\n\n\treturn Object.assign(helperStatic, tables) as RelationsBuilder<TTables>;\n}\n\nexport function defineRelations<\n\tTSchema extends Record<string, unknown>,\n\tTConfig extends RelationsBuilderConfig<TTables>,\n\tTTables extends Record<string, Table | View> = ExtractTablesFromSchema<TSchema>,\n>(\n\tschema: TSchema,\n\trelations?: (helpers: RelationsBuilder<TTables>) => TConfig,\n): Relations<TSchema, TTables, TConfig> {\n\treturn new Relations(\n\t\tschema,\n\t\tschema as unknown as TTables,\n\t\trelations ? relations(createRelationsHelper(schema as unknown as TTables)) : {},\n\t) as Relations<TSchema, TTables, TConfig>;\n}\n\nexport interface WithContainer<TRelatedTables extends Record<string, Table> = Record<string, Table>> {\n\twith?: {\n\t\t[K in keyof TRelatedTables]?: boolean | AnyDBQueryConfig;\n\t};\n}\n\nexport interface ColumnWithTSName {\n\tcolumn: Column | SQL | SQLWrapper | SQL.Aliased;\n\ttsName: string;\n}\n\nexport type RelationsOrder<TColumns extends FieldSelection> = {\n\t[K in keyof TColumns]?: 'asc' | 'desc';\n};\n\nexport type OrderBy = Exclude<AnyDBQueryConfig['orderBy'], undefined>;\n\nexport type Extras = Exclude<AnyDBQueryConfig['extras'], undefined>;\n\n/** @internal */\nexport function fieldSelectionToSQL(table: Table | View, target: string) {\n\tconst field = table[Columns][target];\n\n\treturn field\n\t\t? is(field, Column)\n\t\t\t? field\n\t\t\t: is(field, SQL.Aliased)\n\t\t\t? sql`${table}.${sql.identifier(field.fieldAlias)}`\n\t\t\t: sql`${table}.${sql.identifier(target)}`\n\t\t: sql`${table}.${sql.identifier(target)}`;\n}\n\nfunction relationsFieldFilterToSQL(column: SQLWrapper, filter: RelationsFieldFilter<unknown>): SQL | undefined {\n\tif (typeof filter !== 'object' || is(filter, Placeholder)) return eq(column, filter);\n\n\tconst entries = Object.entries(filter as RelationFieldsFilterInternals<unknown>);\n\tif (!entries.length) return undefined;\n\n\tconst parts: (SQL)[] = [];\n\tfor (const [target, value] of entries) {\n\t\tif (value === undefined) continue;\n\n\t\tswitch (target as keyof RelationFieldsFilterInternals<unknown>) {\n\t\t\tcase 'NOT': {\n\t\t\t\tconst res = relationsFieldFilterToSQL(column, value as RelationsFieldFilter<unknown>);\n\t\t\t\tif (!res) continue;\n\n\t\t\t\tparts.push(not(res));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'OR': {\n\t\t\t\tif (!(value as RelationsFieldFilter<unknown>[]).length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tor(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) => relationsFieldFilterToSQL(column, subFilter)),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'AND': {\n\t\t\t\tif (!(value as RelationsFieldFilter<unknown>[]).length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tand(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) => relationsFieldFilterToSQL(column, subFilter)),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'isNotNull':\n\t\t\tcase 'isNull': {\n\t\t\t\tif (!value) continue;\n\n\t\t\t\tparts.push(operators[target as 'isNull' | 'isNotNull'](column));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'in': {\n\t\t\t\tparts.push(operators.inArray(column, value as any[] | Placeholder));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcase 'notIn': {\n\t\t\t\tparts.push(operators.notInArray(column, value as any[] | Placeholder));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tparts.push(\n\t\t\t\t\t(operators[target as keyof typeof operators] as ((col: SQLWrapper, data: any) => SQL | undefined))(\n\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!parts.length) return undefined;\n\n\treturn and(...parts);\n}\n\nexport function relationsFilterToSQL(\n\ttable: Table | View,\n\tfilter: AnyRelationsFilter | AnyTableFilter,\n): SQL | undefined;\nexport function relationsFilterToSQL(\n\ttable: Table | View,\n\tfilter: AnyRelationsFilter | AnyTableFilter,\n\ttableRelations: Record<string, Relation>,\n\ttablesRelations: TablesRelationalConfig,\n\ttableNamesMap: Record<string, string>,\n\tcasing: CasingCache,\n\tdepth?: number,\n): SQL | undefined;\nexport function relationsFilterToSQL(\n\ttable: Table | View,\n\tfilter: AnyRelationsFilter | AnyTableFilter,\n\ttableRelations: Record<string, Relation> = {},\n\ttablesRelations: TablesRelationalConfig = {},\n\ttableNamesMap: Record<string, string> = {},\n\tcasing?: CasingCache,\n\tdepth: number = 0,\n): SQL | undefined {\n\tconst entries = Object.entries(filter);\n\tif (!entries.length) return undefined;\n\n\tconst parts: SQL[] = [];\n\tfor (const [target, value] of entries) {\n\t\tif (value === undefined) continue;\n\n\t\tswitch (target) {\n\t\t\tcase 'RAW': {\n\t\t\t\tconst processed = typeof value === 'function'\n\t\t\t\t\t? (value as unknown as (table: FieldSelection, operators: Operators) => SQL)(table as any, operators)\n\t\t\t\t\t: (value as SQLWrapper).getSQL();\n\n\t\t\t\tparts.push(processed);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcase 'OR': {\n\t\t\t\tif (!(value as AnyRelationsFilter[] | undefined)?.length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tor(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) =>\n\t\t\t\t\t\t\trelationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, tableNamesMap, casing!, depth)\n\t\t\t\t\t\t),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcase 'AND': {\n\t\t\t\tif (!(value as AnyRelationsFilter[] | undefined)?.length) continue;\n\n\t\t\t\tparts.push(\n\t\t\t\t\tand(\n\t\t\t\t\t\t...(value as AnyRelationsFilter[]).map((subFilter) =>\n\t\t\t\t\t\t\trelationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, tableNamesMap, casing!, depth)\n\t\t\t\t\t\t),\n\t\t\t\t\t)!,\n\t\t\t\t);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcase 'NOT': {\n\t\t\t\tif (value === undefined) continue;\n\n\t\t\t\tconst built = relationsFilterToSQL(\n\t\t\t\t\ttable,\n\t\t\t\t\tvalue as AnyRelationsFilter,\n\t\t\t\t\ttableRelations,\n\t\t\t\t\ttablesRelations,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\tcasing!,\n\t\t\t\t\tdepth,\n\t\t\t\t);\n\t\t\t\tif (!built) continue;\n\n\t\t\t\tparts.push(not(built));\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tif (table[Columns][target]) {\n\t\t\t\t\tconst column = fieldSelectionToSQL(table, target);\n\n\t\t\t\t\tconst colFilter = relationsFieldFilterToSQL(\n\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\tvalue as RelationsFieldFilter,\n\t\t\t\t\t);\n\t\t\t\t\tif (colFilter) parts.push(colFilter);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst relation = tableRelations[target];\n\t\t\t\tif (!relation) {\n\t\t\t\t\t// Should never trigger unless the types've been violated\n\t\t\t\t\tthrow new DrizzleError({\n\t\t\t\t\t\tmessage: `Unknown relational filter field: \"${target}\"`,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst targetTable = aliasedTable(relation.targetTable, `f${depth}`);\n\t\t\t\tconst throughTable = relation.throughTable ? aliasedTable(relation.throughTable, `ft${depth}`) : undefined;\n\t\t\t\tconst targetConfig = tablesRelations[tableNamesMap[getTableUniqueName(relation.targetTable)]!]!;\n\n\t\t\t\tconst {\n\t\t\t\t\tfilter: relationFilter,\n\t\t\t\t\tjoinCondition,\n\t\t\t\t} = relationToSQL(casing!, relation, table, targetTable, throughTable);\n\t\t\t\tconst subfilter = typeof value === 'boolean' ? undefined : relationsFilterToSQL(\n\t\t\t\t\ttargetTable,\n\t\t\t\t\tvalue as AnyRelationsFilter,\n\t\t\t\t\ttargetConfig.relations,\n\t\t\t\t\ttablesRelations,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\tcasing!,\n\t\t\t\t\tdepth + 1,\n\t\t\t\t);\n\t\t\t\tconst filter = and(\n\t\t\t\t\trelationFilter,\n\t\t\t\t\tsubfilter,\n\t\t\t\t);\n\n\t\t\t\tconst subquery = throughTable\n\t\t\t\t\t? sql`(select * from ${getTableAsAliasSQL(targetTable)} inner join ${\n\t\t\t\t\t\tgetTableAsAliasSQL(throughTable)\n\t\t\t\t\t} on ${joinCondition}${sql` where ${filter}`.if(filter)} limit 1)`\n\t\t\t\t\t: sql`(select * from ${getTableAsAliasSQL(targetTable)}${sql` where ${filter}`.if(filter)} limit 1)`;\n\t\t\t\tif (filter) parts.push((value ? exists : notExists)(subquery));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn and(...parts)!;\n}\n\nexport function relationsOrderToSQL(\n\ttable: Table | View,\n\torders: OrderBy,\n): SQL | undefined {\n\tif (typeof orders === 'function') {\n\t\tconst data = orders(table as any, orderByOperators);\n\n\t\treturn is(data, SQL)\n\t\t\t? data\n\t\t\t: Array.isArray(data)\n\t\t\t? data.length\n\t\t\t\t? sql.join(data.map((o) => is(o, SQL) ? o : asc(o)), sql`, `)\n\t\t\t\t: undefined\n\t\t\t: is(data, Column)\n\t\t\t? asc(data)\n\t\t\t: undefined;\n\t}\n\n\tconst entries = Object.entries(orders).filter(([_, value]) => value);\n\tif (!entries.length) return undefined;\n\n\treturn sql.join(\n\t\tentries.map(([target, value]) => (value === 'asc' ? asc : desc)(fieldSelectionToSQL(table, target))),\n\t\tsql`, `,\n\t);\n}\n\nexport function relationExtrasToSQL(\n\ttable: Table | View,\n\textras: Extras,\n) {\n\tconst subqueries: SQL[] = [];\n\tconst selection: BuildRelationalQueryResult['selection'] = [];\n\n\tfor (\n\t\tconst [key, field] of Object.entries(extras)\n\t) {\n\t\tif (!field) continue;\n\t\tconst extra = typeof field === 'function' ? field(table as any, { sql: operators.sql }) : field;\n\n\t\tconst query = sql`(${extra.getSQL()}) as ${sql.identifier(key)}`;\n\n\t\tquery.decoder = extra.getSQL().decoder;\n\n\t\tsubqueries.push(query);\n\t\tselection.push({\n\t\t\tkey,\n\t\t\tfield: query,\n\t\t});\n\t}\n\n\treturn {\n\t\tsql: subqueries.length ? sql.join(subqueries, sql`, `) : undefined,\n\t\tselection,\n\t};\n}\n\nexport interface BuiltRelationFilters {\n\tfilter?: SQL;\n\tjoinCondition?: SQL;\n}\n\nexport function relationToSQL(\n\tcasing: CasingCache,\n\trelation: Relation,\n\tsourceTable: Table | View,\n\ttargetTable: Table | View,\n\tthroughTable?: Table | View,\n): BuiltRelationFilters {\n\tif (relation.through) {\n\t\tconst outerColumnWhere = relation.sourceColumns.map((s, i) => {\n\t\t\tconst t = relation.through!.source[i]!;\n\n\t\t\treturn eq(\n\t\t\t\tsql`${sourceTable}.${sql.identifier(casing.getColumnCasing(s))}`,\n\t\t\t\tsql`${throughTable!}.${sql.identifier(is(t._.column, Column) ? casing.getColumnCasing(t._.column) : t._.key)}`,\n\t\t\t);\n\t\t});\n\n\t\tconst innerColumnWhere = relation.targetColumns.map((s, i) => {\n\t\t\tconst t = relation.through!.target[i]!;\n\n\t\t\treturn eq(\n\t\t\t\tsql`${throughTable!}.${sql.identifier(is(t._.column, Column) ? casing.getColumnCasing(t._.column) : t._.key)}`,\n\t\t\t\tsql`${targetTable}.${sql.identifier(casing.getColumnCasing(s))}`,\n\t\t\t);\n\t\t});\n\n\t\treturn {\n\t\t\tfilter: and(\n\t\t\t\trelation.where\n\t\t\t\t\t? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where)\n\t\t\t\t\t: undefined,\n\t\t\t\t...outerColumnWhere,\n\t\t\t),\n\t\t\tjoinCondition: and(...innerColumnWhere),\n\t\t};\n\t}\n\n\tconst columnWhere = relation.sourceColumns.map((s, i) => {\n\t\tconst t = relation.targetColumns[i]!;\n\n\t\treturn eq(\n\t\t\tsql`${sourceTable}.${sql.identifier(casing.getColumnCasing(s))}`,\n\t\t\tsql`${targetTable}.${sql.identifier(casing.getColumnCasing(t))}`,\n\t\t);\n\t});\n\n\tconst fullWhere = and(\n\t\t...columnWhere,\n\t\trelation.where\n\t\t\t? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where)\n\t\t\t: undefined,\n\t)!;\n\n\treturn { filter: fullWhere };\n}\n\nexport function getTableAsAliasSQL(table: Table | View) {\n\treturn sql`${\n\t\ttable[IsAlias]\n\t\t\t? sql`${sql`${sql.identifier(table[Schema] ?? '')}.`.if(table[Schema])}${\n\t\t\t\tsql.identifier(table[OriginalName])\n\t\t\t} as ${table}`\n\t\t\t: table\n\t}`;\n}\n"],"mappings":"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","names":["import_table","acc","filter"]}