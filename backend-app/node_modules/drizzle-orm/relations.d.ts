import { type AnyTable, Table } from "./table.js";
import type { CasingCache } from "./casing.js";
import { type AnyColumn, Column } from "./column.js";
import { entityKind } from "./entity.js";
import { and, asc, between, desc, exists, ilike, inArray, isNotNull, isNull, like, not, notBetween, notExists, notIlike, notInArray, notLike, or } from "./sql/expressions/index.js";
import { Placeholder, SQL, sql, type SQLWrapper, View } from "./sql/sql.js";
import type { Assume, DrizzleTypeError, Equal, Simplify, ValueOrArray } from "./utils.js";
export type FieldValue = Column | SQLWrapper | SQL.Aliased | SQL;
export type FieldSelection = Record<string, FieldValue>;
export declare class Relations<TSchema extends Record<string, unknown> = Record<string, unknown>, TTables extends Record<string, Table | View> = Record<string, Table | View>, TConfig extends RelationsBuilderConfig<TTables> = RelationsBuilderConfig<TTables>> {
    readonly schema: TSchema;
    readonly tables: TTables;
    readonly config: TConfig;
    static readonly [entityKind]: string;
    readonly $brand: 'RelationsV2';
    /** table DB name -> schema table key */
    readonly tableNamesMap: Record<string, string>;
    readonly tablesConfig: TablesRelationalConfig;
    constructor(schema: TSchema, tables: TTables, config: TConfig);
}
export type EmptyRelations = Relations<Record<string, never>, Record<string, never>, Record<string, never>>;
export type AnyRelations = Relations<Record<string, any>, Record<string, any>, Record<string, any>>;
export declare abstract class Relation<TSourceTableName extends string = string, TTargetTableName extends string = string> {
    readonly targetTable: AnyTable<{
        name: TTargetTableName;
    }> | View<TTargetTableName>;
    static readonly [entityKind]: string;
    readonly $brand: 'RelationV2';
    fieldName: string;
    sourceColumns: AnyColumn<{
        tableName: TSourceTableName;
    }>[];
    targetColumns: AnyColumn<{
        tableName: TTargetTableName;
    }>[];
    alias: string | undefined;
    where: AnyTableFilter | undefined;
    sourceTable: AnyTable<{
        name: TSourceTableName;
    }> | View<TSourceTableName>;
    through?: {
        source: RelationsBuilderColumnBase[];
        target: RelationsBuilderColumnBase[];
    };
    throughTable?: Table | View;
    isReversed?: boolean;
    constructor(targetTable: AnyTable<{
        name: TTargetTableName;
    }> | View<TTargetTableName>);
}
export declare class One<TSourceTableName extends string, TTargetTableName extends string, TOptional extends boolean = boolean> extends Relation<TSourceTableName, TTargetTableName> {
    static readonly [entityKind]: string;
    protected $relationBrand: 'OneV2';
    readonly optional: TOptional;
    constructor(tables: Record<string, Table | View>, targetTable: AnyTable<{
        name: TTargetTableName;
    }> | View<TTargetTableName>, config: AnyOneConfig | undefined);
}
export declare class Many<TSourceTableName extends string, TTargetTableName extends string> extends Relation<TSourceTableName, TTargetTableName> {
    readonly config: AnyManyConfig | undefined;
    static readonly [entityKind]: string;
    protected $relationBrand: 'ManyV2';
    constructor(tables: Record<string, Table | View>, targetTable: AnyTable<{
        name: TTargetTableName;
    }> | View<TTargetTableName>, config: AnyManyConfig | undefined);
}
export declare abstract class AggregatedField<T = unknown> implements SQLWrapper<T> {
    static readonly [entityKind]: string;
    readonly $brand: 'AggregatedField';
    readonly _: {
        readonly data: T;
    };
    protected table: Table | View | undefined;
    onTable(table: Table | View): this;
    abstract getSQL(): SQL<T>;
}
export declare class Count extends AggregatedField<number> {
    static readonly [entityKind]: string;
    protected $aggregatedFieldBrand: 'Count';
    private query;
    getSQL(): SQL<number>;
}
export type ExtractObjectValues<T> = T[keyof T];
export type ExtractRelationsFromTableExtraConfigSchema<TConfig extends unknown[]> = ExtractObjectValues<{
    [K in keyof TConfig as TConfig[K] extends Relations<any> ? K : never]: TConfig[K] extends Relations<infer TRelationConfig> ? TRelationConfig : never;
}>;
export declare const operators: {
    and: typeof and;
    between: typeof between;
    eq: import("./expressions.js").BinaryOperator;
    exists: typeof exists;
    gt: import("./expressions.js").BinaryOperator;
    gte: import("./expressions.js").BinaryOperator;
    ilike: typeof ilike;
    inArray: typeof inArray;
    isNull: typeof isNull;
    isNotNull: typeof isNotNull;
    like: typeof like;
    lt: import("./expressions.js").BinaryOperator;
    lte: import("./expressions.js").BinaryOperator;
    ne: import("./expressions.js").BinaryOperator;
    not: typeof not;
    notBetween: typeof notBetween;
    notExists: typeof notExists;
    notLike: typeof notLike;
    notIlike: typeof notIlike;
    notInArray: typeof notInArray;
    or: typeof or;
    sql: typeof sql;
};
export type Operators = typeof operators;
export declare const orderByOperators: {
    sql: typeof sql;
    asc: typeof asc;
    desc: typeof desc;
};
export declare function getOrderByOperators(): {
    sql: typeof sql;
    asc: typeof asc;
    desc: typeof desc;
};
export type OrderByOperators = ReturnType<typeof getOrderByOperators>;
export type FindTableInRelationalConfig<TSchema extends TablesRelationalConfig, TTargetTable extends Table | View, TTableName extends string = TTargetTable['_']['name']> = ExtractObjectValues<{
    [K in keyof TSchema as TSchema[K]['tsName'] extends TTableName ? K : never]: TSchema[K];
}>;
export interface SQLOperator {
    sql: Operators['sql'];
}
export type DBQueryConfig<TRelationType extends 'one' | 'many' = 'one' | 'many', TSchema extends TablesRelationalConfig = TablesRelationalConfig, TTableConfig extends TableRelationalConfig = TableRelationalConfig, TIsNested extends boolean = false> = (TTableConfig['relations'] extends Record<string, never> ? {} : {
    with?: {
        [K in keyof TTableConfig['relations']]?: boolean | (TTableConfig['relations'][K] extends Relation ? DBQueryConfig<TTableConfig['relations'][K] extends One<string, string> ? 'one' : 'many', TSchema, FindTableInRelationalConfig<TSchema, TTableConfig['relations'][K]['targetTable']>, true> : never) | undefined;
    } | undefined;
}) & {
    columns?: {
        [K in keyof TTableConfig['columns']]?: boolean | undefined;
    } | undefined;
    where?: RelationsFilter<TTableConfig, TSchema> | undefined;
    extras?: Record<string, SQLWrapper | ((table: TTableConfig['table'], operators: SQLOperator) => SQLWrapper)> | undefined;
} & (`${TRelationType}_${TIsNested}` extends 'one_true' ? {} : {
    orderBy?: {
        [K in keyof TTableConfig['columns']]?: 'asc' | 'desc' | undefined;
    } | ((table: TTableConfig['table'], operators: OrderByOperators) => ValueOrArray<AnyColumn | SQL>) | undefined;
    offset?: number | Placeholder | undefined;
}) & (TRelationType extends 'many' ? {
    limit?: number | Placeholder | undefined;
} : {});
export type AnyDBQueryConfig = {
    columns?: {
        [K in keyof TableRelationalConfig['columns']]?: boolean | undefined;
    } | undefined;
    where?: RelationsFilter<TableRelationalConfig, TablesRelationalConfig> | undefined;
    extras?: Record<string, SQLWrapper | ((table: TableRelationalConfig['table'], operators: SQLOperator) => SQLWrapper)> | undefined;
    with?: {
        [K in keyof TableRelationalConfig['relations']]?: boolean | (TableRelationalConfig['relations'][K] extends Relation ? DBQueryConfig<TableRelationalConfig['relations'][K] extends One<string, string> ? 'one' : 'many', TablesRelationalConfig, FindTableInRelationalConfig<TablesRelationalConfig, TableRelationalConfig['relations'][K]['targetTable']>> : never) | undefined;
    } | undefined;
    orderBy?: {
        [K in keyof TableRelationalConfig['columns']]?: 'asc' | 'desc' | undefined;
    } | ((table: TableRelationalConfig['table'], operators: OrderByOperators) => ValueOrArray<AnyColumn | SQL>) | undefined;
    offset?: number | Placeholder | undefined;
    limit?: number | Placeholder | undefined;
};
export interface TableRelationalConfig {
    table: Table | View;
    tsName: string;
    dbName: string;
    schema: string | undefined;
    columns: FieldSelection;
    relations: Record<string, RelationsBuilderEntry>;
}
export type TablesRelationalConfig = Record<string, TableRelationalConfig>;
export interface RelationalSchemaConfig<TTablesConfig extends TablesRelationalConfig> {
    tables: Record<string, Table>;
    tablesConfig: TTablesConfig;
    tableNamesMap: Record<string, string>;
}
type NonUndefinedRecord<TRecord extends Record<string, any>> = {
    [K in keyof TRecord as K extends undefined ? never : K]: TRecord[K];
};
export type ExtractTablesWithRelations<TRelations extends Relations, TTables extends Record<string, Table | View> = TRelations['tables']> = {
    [K in keyof TTables]: {
        table: TTables[K];
        tsName: K & string;
        dbName: TTables[K]['_']['name'];
        columns: TTables[K] extends Table ? TTables[K]['_']['columns'] : Assume<TTables[K], View>['_']['selectedFields'];
        relations: K extends keyof TRelations['config'] ? TRelations['config'][K] extends Record<string, any> ? NonUndefinedRecord<TRelations['config'][K]> : Record<string, never> : Record<string, never>;
        schema: TTables[K] extends Table ? TTables[K]['_']['schema'] : string | undefined;
    };
};
export type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R : T;
export type BuildRelationResult<TConfig extends TablesRelationalConfig, TInclude, TRelations extends Record<string, RelationsBuilderEntry>> = {
    [K in TruthyKeysOnly<TInclude> & keyof TRelations]: TRelations[K] extends infer TRel extends Relation ? BuildQueryResult<TConfig, FindTableInRelationalConfig<TConfig, TRel['targetTable']>, Assume<TInclude[K], true | Record<string, unknown>>> extends infer TResult ? TRel extends One<string, string> ? TResult | (Equal<TRel['optional'], true> extends true ? null : TInclude[K] extends Record<string, unknown> ? TInclude[K]['where'] extends Record<string, any> ? null : never : never) : TResult[] : never : TRelations[K] extends AggregatedField<infer TData> ? TData : never;
};
export type NonUndefinedKeysOnly<T> = ExtractObjectValues<{
    [K in keyof T as T[K] extends undefined ? never : K]: K;
}> & keyof T;
export type TruthyKeysOnly<T> = ExtractObjectValues<{
    [K in keyof T as T[K] extends undefined | false ? never : K]: K;
}> & keyof T;
export type InferRelationalQueryTableResult<TTable extends Table | View, TRawSelection extends Record<string, unknown>, TSelectedFields extends Record<string, unknown> | 'Full' = 'Full', TFilteredSelection extends Record<string, unknown> = TSelectedFields extends 'Full' ? TRawSelection : {
    [K in Equal<Exclude<TSelectedFields[keyof TSelectedFields & keyof TRawSelection], undefined>, false> extends true ? Exclude<keyof TRawSelection, NonUndefinedKeysOnly<TSelectedFields>> : {
        [K in keyof TSelectedFields]: Equal<TSelectedFields[K], true> extends true ? K : never;
    }[keyof TSelectedFields] & keyof TRawSelection]: TRawSelection[K];
}> = {
    [K in keyof TFilteredSelection]: TTable['$inferSelect'][Assume<K, keyof TTable['$inferSelect']>];
};
export type BuildQueryResult<TSchema extends TablesRelationalConfig, TTableConfig extends TableRelationalConfig, TFullSelection extends true | Record<string, unknown>> = Equal<TFullSelection, true> extends true ? Simplify<InferRelationalQueryTableResult<TTableConfig['table'], TTableConfig['columns']>> : TFullSelection extends Record<string, unknown> ? Simplify<(InferRelationalQueryTableResult<TTableConfig['table'], TTableConfig['columns'], TFullSelection['columns'] extends Record<string, unknown> ? TFullSelection['columns'] : 'Full'>) & (TFullSelection['extras'] extends Record<string, SQLWrapper | ((...args: any[]) => SQLWrapper)> ? {
    [K in NonUndefinedKeysOnly<ReturnTypeOrValue<TFullSelection['extras']>>]: ReturnType<Assume<ReturnTypeOrValue<TFullSelection['extras'][K]>, SQLWrapper>['getSQL']>['_']['type'];
} : {}) & (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<TSchema, TFullSelection['with'], TTableConfig['relations']> : {})> : never;
export interface NormalizedRelation {
    fields: AnyColumn[];
    references: AnyColumn[];
}
export interface BuildRelationalQueryResult {
    selection: {
        key: string;
        field: Column | Table | SQL | SQL.Aliased | SQLWrapper | AggregatedField;
        isArray?: boolean;
        selection?: BuildRelationalQueryResult['selection'];
        isOptional?: boolean;
    }[];
    sql: SQL;
}
export declare function mapRelationalRow(row: Record<string, unknown>, buildQueryResultSelection: BuildRelationalQueryResult['selection'], mapColumnValue?: (value: unknown) => unknown, 
/** Needed for SQLite as it returns JSON values as strings */
parseJson?: boolean, path?: string): Record<string, unknown>;
export declare class RelationsBuilderTable<TTableName extends string = string> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly name: TTableName;
        readonly table: AnyTable<{
            name: TTableName;
        }> | View<TTableName>;
    };
    constructor(table: AnyTable<{
        name: TTableName;
    }> | View<TTableName>, key: string);
}
export interface RelationsBuilderColumnConfig<TTableName extends string = string, TData = unknown> {
    readonly tableName: TTableName;
    readonly data: TData;
    readonly column: AnyColumn<{
        tableName: TTableName;
    }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>;
    readonly through?: RelationsBuilderColumnBase;
    readonly key: string;
}
export type RelationsBuilderColumnBase<TTableName extends string = string, TData = unknown> = {
    _: RelationsBuilderColumnConfig<TTableName, TData>;
};
export declare class RelationsBuilderColumn<TTableName extends string = string, TData = unknown> implements RelationsBuilderColumnBase<TTableName, TData> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly tableName: TTableName;
        readonly data: TData;
        readonly column: AnyColumn<{
            tableName: TTableName;
        }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>;
        readonly key: string;
    };
    constructor(column: AnyColumn<{
        tableName: TTableName;
    }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>, tableName: TTableName, key: string);
    through(column: RelationsBuilderColumn): RelationsBuilderJunctionColumn<TTableName, TData>;
}
export declare class RelationsBuilderJunctionColumn<TTableName extends string = string, TData = unknown> implements RelationsBuilderColumnBase<TTableName, TData> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly tableName: TTableName;
        readonly data: TData;
        readonly column: AnyColumn<{
            tableName: TTableName;
        }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>;
        readonly through: RelationsBuilderColumnBase;
        readonly key: string;
    };
    constructor(column: AnyColumn<{
        tableName: TTableName;
    }> | SQL<TData> | SQLWrapper<TData> | SQL.Aliased<TData>, tableName: TTableName, key: string, through: RelationsBuilderColumnBase);
}
export interface RelationFieldsFilterInternals<T> {
    eq?: T | Placeholder | undefined;
    ne?: T | Placeholder | undefined;
    gt?: T | Placeholder | undefined;
    gte?: T | Placeholder | undefined;
    lt?: T | Placeholder | undefined;
    lte?: T | Placeholder | undefined;
    in?: (T | Placeholder)[] | Placeholder | undefined;
    notIn?: (T | Placeholder)[] | Placeholder | undefined;
    like?: string | Placeholder | undefined;
    ilike?: string | Placeholder | undefined;
    notLike?: string | Placeholder | undefined;
    notIlike?: string | Placeholder | undefined;
    isNull?: true | undefined;
    isNotNull?: true | undefined;
    NOT?: RelationsFieldFilter<T> | undefined;
    OR?: RelationsFieldFilter<T>[] | undefined;
    AND?: RelationsFieldFilter<T>[] | undefined;
}
export type RelationsFieldFilter<T = unknown> = RelationFieldsFilterInternals<T> | (unknown extends T ? never : T extends object ? never : T) | Placeholder;
export interface RelationsFilterCommons<TTable extends TableRelationalConfig = TableRelationalConfig, TSchema extends TablesRelationalConfig = TablesRelationalConfig> {
    OR?: RelationsFilter<TTable, TSchema>[] | undefined;
    NOT?: RelationsFilter<TTable, TSchema> | undefined;
    AND?: RelationsFilter<TTable, TSchema>[] | undefined;
    RAW?: SQLWrapper | ((table: TTable['table'], operators: Operators) => SQL) | undefined;
}
export type RelationsFilter<TTable extends TableRelationalConfig, TSchema extends TablesRelationalConfig, TRelations extends Record<string, Relation> = TTable['relations'], TColumns extends FieldSelection = TTable['columns']> = TTable['relations'] extends Record<string, never> ? TableFilter<TTable['table']> : {
    [K in keyof TColumns]?: (TColumns[K] extends Column ? RelationsFieldFilter<TColumns[K]['_']['data']> : RelationsFieldFilter<unknown>) | undefined;
} & {
    [K in keyof TRelations]?: boolean | RelationsFilter<FindTableInRelationalConfig<TSchema, TRelations[K]['targetTable']>, TSchema> | undefined;
} & RelationsFilterCommons<TTable, TSchema>;
export interface TableFilterCommons<TTable extends Table | View = Table | View, TColumns extends FieldSelection = TTable extends View ? Assume<TTable['_']['selectedFields'], FieldSelection> : Assume<TTable, Table>['_']['columns']> {
    OR?: TableFilter<TTable, TColumns>[] | undefined;
    NOT?: TableFilter<TTable, TColumns> | undefined;
    AND?: TableFilter<TTable, TColumns>[] | undefined;
    RAW?: SQLWrapper | ((table: TTable, operators: Operators) => SQL) | undefined;
}
export type TableFilter<TTable extends Table | View = Table | View, TColumns extends FieldSelection = TTable extends View ? Assume<TTable['_']['selectedFields'], FieldSelection> : Assume<TTable, Table>['_']['columns']> = {
    [K in keyof TColumns as K extends keyof TableFilterCommons ? never : K]?: TColumns[K] extends Column ? RelationsFieldFilter<TColumns[K]['_']['data']> : RelationsFieldFilter<unknown>;
} & TableFilterCommons<TTable, TColumns>;
export type AnyRelationsFilter = RelationsFilter<TableRelationalConfig, TablesRelationalConfig, Record<string, Relation>, FieldSelection>;
export type AnyTableFilter = TableFilter<Table | View, FieldSelection>;
export interface OneConfig<TSchema extends Record<string, Table | View>, TSourceColumns extends Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]> | Readonly<RelationsBuilderColumnBase>, TTargetTableName extends string, TOptional extends boolean> {
    from?: TSourceColumns;
    to?: TSourceColumns extends RelationsBuilderJunctionColumn | [RelationsBuilderJunctionColumn, ...RelationsBuilderJunctionColumn[]] ? RelationsBuilderJunctionColumn<TTargetTableName> | [
        RelationsBuilderJunctionColumn<TTargetTableName>,
        ...RelationsBuilderJunctionColumn<TTargetTableName>[]
    ] : TSourceColumns extends [RelationsBuilderColumn] ? RelationsBuilderColumn<TTargetTableName> | [RelationsBuilderColumn<TTargetTableName>] : TSourceColumns extends [RelationsBuilderColumn, ...RelationsBuilderColumn[]] ? {
        [K in keyof TSourceColumns]: RelationsBuilderColumn<TTargetTableName>;
    } : RelationsBuilderColumn<TTargetTableName>;
    where?: TableFilter<TSchema[TTargetTableName]>;
    optional?: TOptional;
    alias?: string;
}
export type AnyOneConfig = OneConfig<Record<string, Table | View>, Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]] | RelationsBuilderColumnBase<string, unknown>>, string, boolean>;
export interface ManyConfig<TSchema extends Record<string, Table | View>, TSourceColumns extends Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]> | Readonly<RelationsBuilderColumnBase>, TTargetTableName extends string> {
    from?: TSourceColumns;
    to?: TSourceColumns extends RelationsBuilderJunctionColumn | [RelationsBuilderJunctionColumn, ...RelationsBuilderJunctionColumn[]] ? RelationsBuilderJunctionColumn<TTargetTableName> | [
        RelationsBuilderJunctionColumn<TTargetTableName>,
        ...RelationsBuilderJunctionColumn<TTargetTableName>[]
    ] : TSourceColumns extends [RelationsBuilderColumn] ? RelationsBuilderColumn<TTargetTableName> | [RelationsBuilderColumn<TTargetTableName>] : TSourceColumns extends [RelationsBuilderColumn, ...RelationsBuilderColumn[]] ? {
        [K in keyof TSourceColumns]: RelationsBuilderColumn<TTargetTableName>;
    } : RelationsBuilderColumn<TTargetTableName>;
    where?: TableFilter<TSchema[TTargetTableName]>;
    alias?: string;
}
export type AnyManyConfig = ManyConfig<Record<string, Table | View>, Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]> | Readonly<RelationsBuilderColumnBase>, string>;
export interface OneFn<TTables extends Record<string, Table | View>, TTargetTableName extends string> {
    <TSourceColumns extends Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]> | RelationsBuilderColumnBase = any, TOptional extends boolean = true>(config?: OneConfig<TTables, TSourceColumns, TTargetTableName, TOptional>): One<TSourceColumns extends [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]] ? TSourceColumns[number]['_']['tableName'] : Assume<TSourceColumns, RelationsBuilderColumnBase>['_']['tableName'], TTargetTableName, TOptional>;
}
export interface ManyFn<TTables extends Record<string, Table | View>, TTargetTableName extends string> {
    <TSourceColumns extends Readonly<[RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]]> | RelationsBuilderColumnBase = any>(config?: ManyConfig<TTables, TSourceColumns, TTargetTableName>): Many<TSourceColumns extends [RelationsBuilderColumnBase, ...RelationsBuilderColumnBase[]] ? TSourceColumns[number]['_']['tableName'] : Assume<TSourceColumns, RelationsBuilderColumnBase>['_']['tableName'], TTargetTableName>;
}
export declare class RelationsHelperStatic<TTables extends Record<string, Table | View>> {
    static readonly [entityKind]: string;
    readonly $brand: 'RelationsHelperStatic';
    readonly _: {
        readonly tables: TTables;
    };
    constructor(tables: TTables);
    one: {
        [K in keyof TTables]: OneFn<TTables, K & string>;
    };
    many: {
        [K in keyof TTables]: ManyFn<TTables, K & string>;
    };
}
export type RelationsBuilder<TSchema extends Record<string, Table | View>> = {
    [TTableName in keyof TSchema & string]: TSchema[TTableName] extends Table | View<string, boolean, FieldSelection> ? ({
        [TColumnName in keyof (TSchema[TTableName] extends Table ? TSchema[TTableName]['_']['columns'] : Assume<TSchema[TTableName], View>['_']['selectedFields'])]: RelationsBuilderColumn<TTableName, (TSchema[TTableName] extends Table ? TSchema[TTableName]['_']['columns'] : Assume<Assume<TSchema[TTableName], View>['_']['selectedFields'], FieldSelection>)[TColumnName] extends infer Field ? Field extends Column ? Field['_']['data'] : Field extends SQLWrapper<infer Data> | SQL<infer Data> | SQL.Aliased<infer Data> ? Data : never : never>;
    } & RelationsBuilderTable<TTableName>) : DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;
} & RelationsHelperStatic<TSchema>;
export type RelationsBuilderConfig<TTables extends Record<string, Table | View>> = {
    [TTableName in keyof TTables & string]?: TTables[TTableName] extends Table | View<string, boolean, FieldSelection> ? Record<string, RelationsBuilderEntry<TTables, TTableName>> : DrizzleTypeError<'Views with nested selections are not supported by the relational query builder'>;
};
export type RelationsBuilderEntry<TTables extends Record<string, Table | View> = Record<string, Table | View>, TSourceTableName extends string = string> = Relation<TSourceTableName, keyof TTables & string>;
export type ExtractTablesFromSchema<TSchema extends Record<string, unknown>> = {
    [K in keyof TSchema as TSchema[K] extends Table | View ? K : never]: TSchema[K] extends Table | View ? TSchema[K] : never;
};
export declare function createRelationsHelper<TSchema extends Record<string, unknown>, TTables extends Record<string, Table | View>>(schema: TSchema): RelationsBuilder<TTables>;
export declare function defineRelations<TSchema extends Record<string, unknown>, TConfig extends RelationsBuilderConfig<TTables>, TTables extends Record<string, Table | View> = ExtractTablesFromSchema<TSchema>>(schema: TSchema, relations?: (helpers: RelationsBuilder<TTables>) => TConfig): Relations<TSchema, TTables, TConfig>;
export interface WithContainer<TRelatedTables extends Record<string, Table> = Record<string, Table>> {
    with?: {
        [K in keyof TRelatedTables]?: boolean | AnyDBQueryConfig;
    };
}
export interface ColumnWithTSName {
    column: Column | SQL | SQLWrapper | SQL.Aliased;
    tsName: string;
}
export type RelationsOrder<TColumns extends FieldSelection> = {
    [K in keyof TColumns]?: 'asc' | 'desc';
};
export type OrderBy = Exclude<AnyDBQueryConfig['orderBy'], undefined>;
export type Extras = Exclude<AnyDBQueryConfig['extras'], undefined>;
export declare function relationsFilterToSQL(table: Table | View, filter: AnyRelationsFilter | AnyTableFilter): SQL | undefined;
export declare function relationsFilterToSQL(table: Table | View, filter: AnyRelationsFilter | AnyTableFilter, tableRelations: Record<string, Relation>, tablesRelations: TablesRelationalConfig, tableNamesMap: Record<string, string>, casing: CasingCache, depth?: number): SQL | undefined;
export declare function relationsOrderToSQL(table: Table | View, orders: OrderBy): SQL | undefined;
export declare function relationExtrasToSQL(table: Table | View, extras: Extras): {
    sql: SQL<unknown> | undefined;
    selection: {
        key: string;
        field: Column | Table | SQL | SQL.Aliased | SQLWrapper | AggregatedField;
        isArray?: boolean;
        selection?: BuildRelationalQueryResult["selection"];
        isOptional?: boolean;
    }[];
};
export interface BuiltRelationFilters {
    filter?: SQL;
    joinCondition?: SQL;
}
export declare function relationToSQL(casing: CasingCache, relation: Relation, sourceTable: Table | View, targetTable: Table | View, throughTable?: Table | View): BuiltRelationFilters;
export declare function getTableAsAliasSQL(table: Table | View): SQL<unknown>;
export {};
