{"version":3,"sources":["../../src/pglite/session.ts"],"sourcesContent":["import type { PGlite, QueryOptions, Results, Row, Transaction } from '@electric-sql/pglite';\nimport type * as V1 from '~/_relations.ts';\nimport { entityKind } from '~/entity.ts';\nimport { type Logger, NoopLogger } from '~/logger.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport { PgTransaction } from '~/pg-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport type { PgQueryResultHKT, PgTransactionConfig, PreparedQueryConfig } from '~/pg-core/session.ts';\nimport { PgPreparedQuery, PgSession } from '~/pg-core/session.ts';\nimport { fillPlaceholders, type Query, type SQL, sql } from '~/sql/sql.ts';\nimport { type Assume, mapResultRow } from '~/utils.ts';\n\nimport { types } from '@electric-sql/pglite';\nimport type { AnyRelations, TablesRelationalConfig } from '~/relations.ts';\n\nexport type PgliteClient = PGlite;\n\nexport class PglitePreparedQuery<T extends PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends PgPreparedQuery<T>\n{\n\tstatic override readonly [entityKind]: string = 'PglitePreparedQuery';\n\n\tprivate rawQueryConfig: QueryOptions;\n\tprivate queryConfig: QueryOptions;\n\n\tconstructor(\n\t\tprivate client: PgliteClient | Transaction,\n\t\tprivate queryString: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper({ sql: queryString, params });\n\t\tthis.rawQueryConfig = {\n\t\t\trowMode: 'object',\n\t\t\tparsers: {\n\t\t\t\t[types.TIMESTAMP]: (value) => value,\n\t\t\t\t[types.TIMESTAMPTZ]: (value) => value,\n\t\t\t\t[types.INTERVAL]: (value) => value,\n\t\t\t\t[types.DATE]: (value) => value,\n\t\t\t\t[1115]: (value) => value,\n\t\t\t\t[1185]: (value) => value,\n\t\t\t\t[1187]: (value) => value,\n\t\t\t\t[1182]: (value) => value,\n\t\t\t},\n\t\t};\n\t\tthis.queryConfig = {\n\t\t\trowMode: 'array',\n\t\t\tparsers: {\n\t\t\t\t[types.TIMESTAMP]: (value) => value,\n\t\t\t\t[types.TIMESTAMPTZ]: (value) => value,\n\t\t\t\t[types.INTERVAL]: (value) => value,\n\t\t\t\t[types.DATE]: (value) => value,\n\t\t\t\t// timestamp[]\n\t\t\t\t[1115]: (value) => value,\n\t\t\t\t// timestamp with timezone[]\n\t\t\t\t[1185]: (value) => value,\n\t\t\t\t// interval[]\n\t\t\t\t[1187]: (value) => value,\n\t\t\t\t// date[]\n\t\t\t\t[1182]: (value) => value,\n\t\t\t},\n\t\t};\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues);\n\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.queryString, params);\n\n\t\tconst { fields, rawQueryConfig, client, queryConfig, joinsNotNullableMap, customResultMapper, queryString } = this;\n\n\t\tif (!fields && !customResultMapper) {\n\t\t\treturn client.query<any[]>(queryString, params, rawQueryConfig);\n\t\t}\n\n\t\tconst result = await client.query<any[]>(queryString, params, queryConfig);\n\n\t\treturn customResultMapper\n\t\t\t? (customResultMapper as (rows: unknown[][]) => T['execute'])(result.rows)\n\t\t\t: result.rows.map((row) => mapResultRow<T['execute']>(fields!, row, joinsNotNullableMap));\n\t}\n\n\tprivate async executeRqbV2(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\tthis.logger.logQuery(this.queryString, params);\n\n\t\tconst { rawQueryConfig, client, customResultMapper, queryString } = this;\n\n\t\tconst result = await client.query<Record<string, unknown>>(queryString, params, rawQueryConfig);\n\n\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => T['execute'])(result.rows);\n\t}\n\n\tall(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['all']> {\n\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\t\tthis.logger.logQuery(this.queryString, params);\n\t\treturn this.client.query(this.queryString, params, this.rawQueryConfig).then((result) => result.rows);\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n\nexport interface PgliteSessionOptions {\n\tlogger?: Logger;\n}\n\nexport class PgliteSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTTablesConfig extends TablesRelationalConfig,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgSession<PgliteQueryResultHKT, TFullSchema, TRelations, TTablesConfig, TSchema> {\n\tstatic override readonly [entityKind]: string = 'PgliteSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: PgliteClient | Transaction,\n\t\tdialect: PgDialect,\n\t\tprivate relations: AnyRelations | undefined,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: PgliteSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t): PgPreparedQuery<T> {\n\t\treturn new PglitePreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tname,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper: (rows: Record<string, unknown>[]) => T['execute'],\n\t): PgPreparedQuery<T> {\n\t\treturn new PglitePreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tname,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: PgliteTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>) => Promise<T>,\n\t\tconfig?: PgTransactionConfig | undefined,\n\t): Promise<T> {\n\t\treturn (this.client as PgliteClient).transaction(async (client) => {\n\t\t\tconst session = new PgliteSession<TFullSchema, TRelations, TTablesConfig, TSchema>(\n\t\t\t\tclient,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.options,\n\t\t\t);\n\t\t\tconst tx = new PgliteTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>(\n\t\t\t\tthis.dialect,\n\t\t\t\tsession,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t);\n\t\t\tif (config) {\n\t\t\t\tawait tx.setTransaction(config);\n\t\t\t}\n\t\t\treturn transaction(tx);\n\t\t}) as Promise<T>;\n\t}\n\n\toverride async count(sql: SQL): Promise<number> {\n\t\tconst res = await this.execute<{ rows: [{ count: string }] }>(sql);\n\t\treturn Number(\n\t\t\tres['rows'][0]['count'],\n\t\t);\n\t}\n}\n\nexport class PgliteTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTTablesConfig extends TablesRelationalConfig,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends PgTransaction<PgliteQueryResultHKT, TFullSchema, TRelations, TTablesConfig, TSchema> {\n\tstatic override readonly [entityKind]: string = 'PgliteTransaction';\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: PgliteTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tconst savepointName = `sp${this.nestedIndex + 1}`;\n\t\tconst tx = new PgliteTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>(\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t\tthis.nestedIndex + 1,\n\t\t);\n\t\tawait tx.execute(sql.raw(`savepoint ${savepointName}`));\n\t\ttry {\n\t\t\tconst result = await transaction(tx);\n\t\t\tawait tx.execute(sql.raw(`release savepoint ${savepointName}`));\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tawait tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\nexport interface PgliteQueryResultHKT extends PgQueryResultHKT {\n\ttype: Results<Assume<this['row'], Row>>;\n}\n"],"mappings":"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","names":["sql"]}