"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc2) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc2 = __getOwnPropDesc(from, key)) || desc2.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var relations_exports = {};
__export(relations_exports, {
  AggregatedField: () => AggregatedField,
  Count: () => Count,
  Many: () => Many,
  One: () => One,
  Relation: () => Relation,
  Relations: () => Relations,
  RelationsBuilderColumn: () => RelationsBuilderColumn,
  RelationsBuilderJunctionColumn: () => RelationsBuilderJunctionColumn,
  RelationsBuilderTable: () => RelationsBuilderTable,
  RelationsHelperStatic: () => RelationsHelperStatic,
  createRelationsHelper: () => createRelationsHelper,
  defineRelations: () => defineRelations,
  fieldSelectionToSQL: () => fieldSelectionToSQL,
  getOrderByOperators: () => getOrderByOperators,
  getTableAsAliasSQL: () => getTableAsAliasSQL,
  mapRelationalRow: () => mapRelationalRow,
  operators: () => operators,
  orderByOperators: () => orderByOperators,
  relationExtrasToSQL: () => relationExtrasToSQL,
  relationToSQL: () => relationToSQL,
  relationsFilterToSQL: () => relationsFilterToSQL,
  relationsOrderToSQL: () => relationsOrderToSQL
});
module.exports = __toCommonJS(relations_exports);
var import_table = require("./table.cjs");
var import_table2 = require("./table.cjs");
var import_alias = require("./alias.cjs");
var import_column = require("./column.cjs");
var import_entity = require("./entity.cjs");
var import_errors = require("./errors.cjs");
var import_expressions = require("./sql/expressions/index.cjs");
var import_sql = require("./sql/sql.cjs");
class Relations {
  constructor(schema, tables, config) {
    this.schema = schema;
    this.tables = tables;
    this.config = config;
    for (const [tsName, table] of Object.entries(tables)) {
      if (config[tsName]?.$drizzleTypeError)
        continue;
      const isTable = (0, import_entity.is)(table, import_table.Table);
      const isView = (0, import_entity.is)(table, import_sql.View);
      if (!(isTable || isView))
        continue;
      this.tableNamesMap[(0, import_table.getTableUniqueName)(table)] = tsName;
      this.tablesConfig[tsName] = {
        table,
        tsName,
        dbName: table[import_table.Table.Symbol.Name],
        schema: table[import_table.Table.Symbol.Schema],
        columns: table[import_table.Table.Symbol.Columns],
        relations: config[tsName] || {}
      };
    }
    for (const tableConfig of Object.values(this.tablesConfig)) {
      for (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {
        if (!(0, import_entity.is)(relation, Relation)) {
          continue;
        }
        relation.sourceTable = tableConfig.table;
        relation.fieldName = relationFieldName;
      }
    }
    for (const tableConfig of Object.values(this.tablesConfig)) {
      for (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {
        if (!(0, import_entity.is)(relation, Relation)) {
          continue;
        }
        const relationPrintName = `relations -> ${tableConfig.tsName}: { ${relationFieldName}: r.${(0, import_entity.is)(relation, One) ? "one" : "many"}.${this.tableNamesMap[(0, import_table.getTableUniqueName)(relation.targetTable)]}(...) }`;
        if (typeof relation.alias === "string" && !relation.alias) {
          throw new Error(`${relationPrintName}: "alias" cannot be an empty string - omit it if you don't need it`);
        }
        if (relation.sourceColumns?.length === 0) {
          throw new Error(`${relationPrintName}: "from" cannot be an empty array`);
        }
        if (relation.targetColumns?.length === 0) {
          throw new Error(`${relationPrintName}: "to" cannot be an empty array`);
        }
        if (relation.sourceColumns && relation.targetColumns) {
          if (relation.sourceColumns.length !== relation.targetColumns.length && !relation.throughTable) {
            throw new Error(
              `${relationPrintName}: "from" and "to" fields without "through" must have the same length`
            );
          }
          if (relation.through) {
            if (relation.through.source.length !== relation.sourceColumns.length || relation.through.target.length !== relation.targetColumns.length) {
              throw new Error(
                `${relationPrintName}: ".through(column)" must be used either on all columns in "from" and "to" or not defined on any of them`
              );
            }
            for (const column of relation.through.source) {
              if (tables[column._.tableName] !== relation.throughTable) {
                throw new Error(
                  `${relationPrintName}: ".through(column)" must be used on the same table by all columns of the relation`
                );
              }
            }
            for (const column of relation.through.target) {
              if (tables[column._.tableName] !== relation.throughTable) {
                throw new Error(
                  `${relationPrintName}: ".through(column)" must be used on the same table by all columns of the relation`
                );
              }
            }
          }
          continue;
        }
        if (relation.sourceColumns || relation.targetColumns) {
          throw new Error(
            `${relationPrintName}: relation must have either both "from" and "to" defined, or none of them`
          );
        }
        let reverseRelation;
        const targetTableTsName = this.tableNamesMap[(0, import_table.getTableUniqueName)(relation.targetTable)];
        if (!targetTableTsName) {
          throw new Error(
            `Table "${(0, import_table.getTableUniqueName)(relation.targetTable)}" not found in provided TS schema`
          );
        }
        const reverseTableConfig = this.tablesConfig[targetTableTsName];
        if (!reverseTableConfig) {
          throw new Error(
            `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and no reverse relations of table "${targetTableTsName}" were found"`
          );
        }
        if (relation.alias) {
          const reverseRelations = Object.values(reverseTableConfig.relations).filter(
            (it) => (0, import_entity.is)(it, Relation) && it.alias === relation.alias && it !== relation
          );
          if (reverseRelations.length > 1) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and multiple relations with alias "${relation.alias}" found in table "${targetTableTsName}": ${reverseRelations.map((it) => `"${it.fieldName}"`).join(", ")}`
            );
          }
          reverseRelation = reverseRelations[0];
          if (!reverseRelation) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and there is no reverse relation of table "${targetTableTsName}" with alias "${relation.alias}"`
            );
          }
        } else {
          const reverseRelations = Object.values(reverseTableConfig.relations).filter(
            (it) => (0, import_entity.is)(it, Relation) && it.targetTable === relation.sourceTable && !it.alias && it !== relation
          );
          if (reverseRelations.length > 1) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and multiple relations between "${targetTableTsName}" and "${this.tableNamesMap[(0, import_table.getTableUniqueName)(relation.sourceTable)] ?? (0, import_table.getTableUniqueName)(relation.sourceTable)}" were found.
Hint: you can specify "alias" on both sides of the relation with the same value`
            );
          }
          reverseRelation = reverseRelations[0];
          if (!reverseRelation) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and no reverse relation of table "${targetTableTsName}" with target table "${this.tableNamesMap[(0, import_table.getTableUniqueName)(relation.sourceTable)] ?? (0, import_table.getTableUniqueName)(relation.sourceTable)}" was found`
            );
          }
        }
        if (!reverseRelation.sourceColumns || !reverseRelation.targetColumns) {
          throw new Error(
            `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and reverse relation "${targetTableTsName}.${reverseRelation.fieldName}" does not have "from"/"to" defined`
          );
        }
        relation.sourceColumns = reverseRelation.targetColumns;
        relation.targetColumns = reverseRelation.sourceColumns;
        relation.through = reverseRelation.through ? {
          source: reverseRelation.through.target,
          target: reverseRelation.through.source
        } : void 0;
        relation.throughTable = reverseRelation.throughTable;
        relation.isReversed = !relation.where;
        relation.where = relation.where ?? reverseRelation.where;
      }
    }
  }
  static [import_entity.entityKind] = "RelationsV2";
  /** table DB name -> schema table key */
  tableNamesMap = {};
  tablesConfig = {};
}
class Relation {
  constructor(targetTable) {
    this.targetTable = targetTable;
  }
  static [import_entity.entityKind] = "RelationV2";
  fieldName;
  sourceColumns;
  targetColumns;
  alias;
  where;
  sourceTable;
  through;
  throughTable;
  isReversed;
}
class One extends Relation {
  static [import_entity.entityKind] = "OneV2";
  optional;
  constructor(tables, targetTable, config) {
    super(targetTable);
    this.alias = config?.alias;
    this.where = config?.where;
    if (config?.from) {
      this.sourceColumns = (Array.isArray(config.from) ? config.from : [config.from]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (config?.to) {
      this.targetColumns = (Array.isArray(config.to) ? config.to : [config.to]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (this.throughTable) {
      this.through = {
        source: (Array.isArray(config?.from) ? config.from : [config.from]).map((c) => c._.through),
        target: (Array.isArray(config?.to) ? config.to : [config.to]).map((c) => c._.through)
      };
    }
    this.optional = config?.optional ?? true;
  }
}
class Many extends Relation {
  constructor(tables, targetTable, config) {
    super(targetTable);
    this.config = config;
    this.alias = config?.alias;
    this.where = config?.where;
    if (config?.from) {
      this.sourceColumns = (Array.isArray(config.from) ? config.from : [config.from]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (config?.to) {
      this.targetColumns = (Array.isArray(config.to) ? config.to : [config.to]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (this.throughTable) {
      this.through = {
        source: (Array.isArray(config?.from) ? config.from : [config.from]).map((c) => c._.through),
        target: (Array.isArray(config?.to) ? config.to : [config.to]).map((c) => c._.through)
      };
    }
  }
  static [import_entity.entityKind] = "ManyV2";
}
class AggregatedField {
  static [import_entity.entityKind] = "AggregatedField";
  table;
  onTable(table) {
    this.table = table;
    return this;
  }
}
class Count extends AggregatedField {
  static [import_entity.entityKind] = "AggregatedFieldCount";
  query;
  getSQL() {
    if (!this.query) {
      if (!this.table)
        throw new Error("Table must be set before building aggregate field");
      this.query = import_sql.sql`select count(*) as ${import_sql.sql.identifier("r")} from ${getTableAsAliasSQL(this.table)}`.mapWith(Number);
    }
    return this.query;
  }
}
const operators = {
  and: import_expressions.and,
  between: import_expressions.between,
  eq: import_expressions.eq,
  exists: import_expressions.exists,
  gt: import_expressions.gt,
  gte: import_expressions.gte,
  ilike: import_expressions.ilike,
  inArray: import_expressions.inArray,
  isNull: import_expressions.isNull,
  isNotNull: import_expressions.isNotNull,
  like: import_expressions.like,
  lt: import_expressions.lt,
  lte: import_expressions.lte,
  ne: import_expressions.ne,
  not: import_expressions.not,
  notBetween: import_expressions.notBetween,
  notExists: import_expressions.notExists,
  notLike: import_expressions.notLike,
  notIlike: import_expressions.notIlike,
  notInArray: import_expressions.notInArray,
  or: import_expressions.or,
  sql: import_sql.sql
};
const orderByOperators = {
  sql: import_sql.sql,
  asc: import_expressions.asc,
  desc: import_expressions.desc
};
function getOrderByOperators() {
  return orderByOperators;
}
function mapRelationalRow(row, buildQueryResultSelection, mapColumnValue = (value) => value, parseJson = false, path) {
  for (const selectionItem of buildQueryResultSelection) {
    if (selectionItem.selection) {
      const currentPath = `${path ? `${path}.` : ""}${selectionItem.key}`;
      if (row[selectionItem.key] === null)
        continue;
      if (parseJson)
        row[selectionItem.key] = JSON.parse(row[selectionItem.key]);
      if (selectionItem.isArray) {
        for (const item of row[selectionItem.key]) {
          mapRelationalRow(
            item,
            selectionItem.selection,
            mapColumnValue,
            false,
            currentPath
          );
        }
        continue;
      }
      mapRelationalRow(
        row[selectionItem.key],
        selectionItem.selection,
        mapColumnValue,
        false,
        currentPath
      );
      continue;
    }
    const field = selectionItem.field;
    const value = mapColumnValue(row[selectionItem.key]);
    if (value === null)
      continue;
    let decoder;
    if ((0, import_entity.is)(field, import_column.Column)) {
      decoder = field;
    } else if ((0, import_entity.is)(field, import_sql.SQL)) {
      decoder = field.decoder;
    } else if ((0, import_entity.is)(field, import_sql.SQL.Aliased)) {
      decoder = field.sql.decoder;
    } else {
      decoder = field.getSQL().decoder;
    }
    row[selectionItem.key] = decoder.mapFromDriverValue(value);
  }
  return row;
}
class RelationsBuilderTable {
  static [import_entity.entityKind] = "RelationsBuilderTable";
  _;
  constructor(table, key) {
    this._ = {
      name: key,
      table
    };
  }
}
class RelationsBuilderColumn {
  static [import_entity.entityKind] = "RelationsBuilderColumn";
  _;
  constructor(column, tableName, key) {
    this._ = {
      tableName,
      data: void 0,
      column,
      key
    };
  }
  through(column) {
    return new RelationsBuilderJunctionColumn(
      this._.column,
      this._.tableName,
      this._.key,
      column
    );
  }
}
class RelationsBuilderJunctionColumn {
  static [import_entity.entityKind] = "RelationsBuilderColumn";
  _;
  constructor(column, tableName, key, through) {
    this._ = {
      tableName,
      data: void 0,
      column,
      through,
      key
    };
  }
}
class RelationsHelperStatic {
  static [import_entity.entityKind] = "RelationsHelperStatic";
  _;
  constructor(tables) {
    this._ = {
      tables
    };
    const one = {};
    const many = {};
    for (const [tableName, table] of Object.entries(tables)) {
      one[tableName] = (config) => {
        return new One(tables, table, config);
      };
      many[tableName] = (config) => {
        return new Many(tables, table, config);
      };
    }
    this.one = one;
    this.many = many;
  }
  one;
  many;
  /** @internal - to be reworked */
  aggs = {
    count() {
      return new Count();
    }
  };
}
function createRelationsHelper(schema) {
  const schemaTables = Object.fromEntries(
    Object.entries(schema).filter((e) => (0, import_entity.is)(e[1], import_table.Table) || (0, import_entity.is)(e[1], import_sql.View))
  );
  const helperStatic = new RelationsHelperStatic(schemaTables);
  const tables = Object.entries(schema).reduce((acc, [tKey, value]) => {
    if ((0, import_entity.is)(value, import_table.Table) || (0, import_entity.is)(value, import_sql.View)) {
      const rTable = new RelationsBuilderTable(value, tKey);
      const columns = Object.entries(value[import_table2.Columns]).reduce(
        (acc2, [cKey, column]) => {
          const rbColumn = new RelationsBuilderColumn(column, tKey, cKey);
          acc2[cKey] = rbColumn;
          return acc2;
        },
        {}
      );
      acc[tKey] = Object.assign(rTable, columns);
    }
    return acc;
  }, {});
  return Object.assign(helperStatic, tables);
}
function defineRelations(schema, relations) {
  return new Relations(
    schema,
    schema,
    relations ? relations(createRelationsHelper(schema)) : {}
  );
}
function fieldSelectionToSQL(table, target) {
  const field = table[import_table2.Columns][target];
  return field ? (0, import_entity.is)(field, import_column.Column) ? field : (0, import_entity.is)(field, import_sql.SQL.Aliased) ? import_sql.sql`${table}.${import_sql.sql.identifier(field.fieldAlias)}` : import_sql.sql`${table}.${import_sql.sql.identifier(target)}` : import_sql.sql`${table}.${import_sql.sql.identifier(target)}`;
}
function relationsFieldFilterToSQL(column, filter) {
  if (typeof filter !== "object" || (0, import_entity.is)(filter, import_sql.Placeholder))
    return (0, import_expressions.eq)(column, filter);
  const entries = Object.entries(filter);
  if (!entries.length)
    return void 0;
  const parts = [];
  for (const [target, value] of entries) {
    if (value === void 0)
      continue;
    switch (target) {
      case "NOT": {
        const res = relationsFieldFilterToSQL(column, value);
        if (!res)
          continue;
        parts.push((0, import_expressions.not)(res));
        continue;
      }
      case "OR": {
        if (!value.length)
          continue;
        parts.push(
          (0, import_expressions.or)(
            ...value.map((subFilter) => relationsFieldFilterToSQL(column, subFilter))
          )
        );
        continue;
      }
      case "AND": {
        if (!value.length)
          continue;
        parts.push(
          (0, import_expressions.and)(
            ...value.map((subFilter) => relationsFieldFilterToSQL(column, subFilter))
          )
        );
        continue;
      }
      case "isNotNull":
      case "isNull": {
        if (!value)
          continue;
        parts.push(operators[target](column));
        continue;
      }
      case "in": {
        parts.push(operators.inArray(column, value));
        continue;
      }
      case "notIn": {
        parts.push(operators.notInArray(column, value));
        continue;
      }
      default: {
        parts.push(
          operators[target](
            column,
            value
          )
        );
        continue;
      }
    }
  }
  if (!parts.length)
    return void 0;
  return (0, import_expressions.and)(...parts);
}
function relationsFilterToSQL(table, filter, tableRelations = {}, tablesRelations = {}, tableNamesMap = {}, casing, depth = 0) {
  const entries = Object.entries(filter);
  if (!entries.length)
    return void 0;
  const parts = [];
  for (const [target, value] of entries) {
    if (value === void 0)
      continue;
    switch (target) {
      case "RAW": {
        const processed = typeof value === "function" ? value(table, operators) : value.getSQL();
        parts.push(processed);
        continue;
      }
      case "OR": {
        if (!value?.length)
          continue;
        parts.push(
          (0, import_expressions.or)(
            ...value.map(
              (subFilter) => relationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, tableNamesMap, casing, depth)
            )
          )
        );
        continue;
      }
      case "AND": {
        if (!value?.length)
          continue;
        parts.push(
          (0, import_expressions.and)(
            ...value.map(
              (subFilter) => relationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, tableNamesMap, casing, depth)
            )
          )
        );
        continue;
      }
      case "NOT": {
        if (value === void 0)
          continue;
        const built = relationsFilterToSQL(
          table,
          value,
          tableRelations,
          tablesRelations,
          tableNamesMap,
          casing,
          depth
        );
        if (!built)
          continue;
        parts.push((0, import_expressions.not)(built));
        continue;
      }
      default: {
        if (table[import_table2.Columns][target]) {
          const column = fieldSelectionToSQL(table, target);
          const colFilter = relationsFieldFilterToSQL(
            column,
            value
          );
          if (colFilter)
            parts.push(colFilter);
          continue;
        }
        const relation = tableRelations[target];
        if (!relation) {
          throw new import_errors.DrizzleError({
            message: `Unknown relational filter field: "${target}"`
          });
        }
        const targetTable = (0, import_alias.aliasedTable)(relation.targetTable, `f${depth}`);
        const throughTable = relation.throughTable ? (0, import_alias.aliasedTable)(relation.throughTable, `ft${depth}`) : void 0;
        const targetConfig = tablesRelations[tableNamesMap[(0, import_table.getTableUniqueName)(relation.targetTable)]];
        const {
          filter: relationFilter,
          joinCondition
        } = relationToSQL(casing, relation, table, targetTable, throughTable);
        const subfilter = typeof value === "boolean" ? void 0 : relationsFilterToSQL(
          targetTable,
          value,
          targetConfig.relations,
          tablesRelations,
          tableNamesMap,
          casing,
          depth + 1
        );
        const filter2 = (0, import_expressions.and)(
          relationFilter,
          subfilter
        );
        const subquery = throughTable ? import_sql.sql`(select * from ${getTableAsAliasSQL(targetTable)} inner join ${getTableAsAliasSQL(throughTable)} on ${joinCondition}${import_sql.sql` where ${filter2}`.if(filter2)} limit 1)` : import_sql.sql`(select * from ${getTableAsAliasSQL(targetTable)}${import_sql.sql` where ${filter2}`.if(filter2)} limit 1)`;
        if (filter2)
          parts.push((value ? import_expressions.exists : import_expressions.notExists)(subquery));
      }
    }
  }
  return (0, import_expressions.and)(...parts);
}
function relationsOrderToSQL(table, orders) {
  if (typeof orders === "function") {
    const data = orders(table, orderByOperators);
    return (0, import_entity.is)(data, import_sql.SQL) ? data : Array.isArray(data) ? data.length ? import_sql.sql.join(data.map((o) => (0, import_entity.is)(o, import_sql.SQL) ? o : (0, import_expressions.asc)(o)), import_sql.sql`, `) : void 0 : (0, import_entity.is)(data, import_column.Column) ? (0, import_expressions.asc)(data) : void 0;
  }
  const entries = Object.entries(orders).filter(([_, value]) => value);
  if (!entries.length)
    return void 0;
  return import_sql.sql.join(
    entries.map(([target, value]) => (value === "asc" ? import_expressions.asc : import_expressions.desc)(fieldSelectionToSQL(table, target))),
    import_sql.sql`, `
  );
}
function relationExtrasToSQL(table, extras) {
  const subqueries = [];
  const selection = [];
  for (const [key, field] of Object.entries(extras)) {
    if (!field)
      continue;
    const extra = typeof field === "function" ? field(table, { sql: operators.sql }) : field;
    const query = import_sql.sql`(${extra.getSQL()}) as ${import_sql.sql.identifier(key)}`;
    query.decoder = extra.getSQL().decoder;
    subqueries.push(query);
    selection.push({
      key,
      field: query
    });
  }
  return {
    sql: subqueries.length ? import_sql.sql.join(subqueries, import_sql.sql`, `) : void 0,
    selection
  };
}
function relationToSQL(casing, relation, sourceTable, targetTable, throughTable) {
  if (relation.through) {
    const outerColumnWhere = relation.sourceColumns.map((s, i) => {
      const t = relation.through.source[i];
      return (0, import_expressions.eq)(
        import_sql.sql`${sourceTable}.${import_sql.sql.identifier(casing.getColumnCasing(s))}`,
        import_sql.sql`${throughTable}.${import_sql.sql.identifier((0, import_entity.is)(t._.column, import_column.Column) ? casing.getColumnCasing(t._.column) : t._.key)}`
      );
    });
    const innerColumnWhere = relation.targetColumns.map((s, i) => {
      const t = relation.through.target[i];
      return (0, import_expressions.eq)(
        import_sql.sql`${throughTable}.${import_sql.sql.identifier((0, import_entity.is)(t._.column, import_column.Column) ? casing.getColumnCasing(t._.column) : t._.key)}`,
        import_sql.sql`${targetTable}.${import_sql.sql.identifier(casing.getColumnCasing(s))}`
      );
    });
    return {
      filter: (0, import_expressions.and)(
        relation.where ? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where) : void 0,
        ...outerColumnWhere
      ),
      joinCondition: (0, import_expressions.and)(...innerColumnWhere)
    };
  }
  const columnWhere = relation.sourceColumns.map((s, i) => {
    const t = relation.targetColumns[i];
    return (0, import_expressions.eq)(
      import_sql.sql`${sourceTable}.${import_sql.sql.identifier(casing.getColumnCasing(s))}`,
      import_sql.sql`${targetTable}.${import_sql.sql.identifier(casing.getColumnCasing(t))}`
    );
  });
  const fullWhere = (0, import_expressions.and)(
    ...columnWhere,
    relation.where ? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where) : void 0
  );
  return { filter: fullWhere };
}
function getTableAsAliasSQL(table) {
  return import_sql.sql`${table[import_table.IsAlias] ? import_sql.sql`${import_sql.sql`${import_sql.sql.identifier(table[import_table.Schema] ?? "")}.`.if(table[import_table.Schema])}${import_sql.sql.identifier(table[import_table.OriginalName])} as ${table}` : table}`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AggregatedField,
  Count,
  Many,
  One,
  Relation,
  Relations,
  RelationsBuilderColumn,
  RelationsBuilderJunctionColumn,
  RelationsBuilderTable,
  RelationsHelperStatic,
  createRelationsHelper,
  defineRelations,
  fieldSelectionToSQL,
  getOrderByOperators,
  getTableAsAliasSQL,
  mapRelationalRow,
  operators,
  orderByOperators,
  relationExtrasToSQL,
  relationToSQL,
  relationsFilterToSQL,
  relationsOrderToSQL
});
//# sourceMappingURL=relations.cjs.map