{"version":3,"sources":["../../src/gel/session.ts"],"sourcesContent":["import type { Client } from 'gel';\nimport type { Transaction } from 'gel/dist/transaction';\nimport type * as V1 from '~/_relations.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { GelDialect } from '~/gel-core/dialect.ts';\nimport type { SelectedFieldsOrdered } from '~/gel-core/query-builders/select.types.ts';\nimport { GelPreparedQuery, GelSession, GelTransaction, type PreparedQueryConfig } from '~/gel-core/session.ts';\nimport { type Logger, NoopLogger } from '~/logger.ts';\nimport type { AnyRelations, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query, type SQL } from '~/sql/sql.ts';\nimport { tracer } from '~/tracing.ts';\nimport { mapResultRow } from '~/utils.ts';\n\nexport type GelClient = Client | Transaction;\n\nexport class GelDbPreparedQuery<T extends PreparedQueryConfig, TIsRqbV2 extends boolean = false>\n\textends GelPreparedQuery<T>\n{\n\tstatic override readonly [entityKind]: string = 'GelPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: GelClient,\n\t\tprivate queryString: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate _isResponseInArrayMode: boolean,\n\t\tprivate customResultMapper?: (\n\t\t\trows: TIsRqbV2 extends true ? Record<string, unknown>[] : unknown[][],\n\t\t) => T['execute'],\n\t\tprivate transaction: boolean = false,\n\t\tprivate isRqbV2Query?: TIsRqbV2,\n\t) {\n\t\tsuper({ sql: queryString, params });\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\tif (this.isRqbV2Query) return this.executeRqbV2(placeholderValues);\n\n\t\treturn tracer.startActiveSpan('drizzle.execute', async () => {\n\t\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\t\tthis.logger.logQuery(this.queryString, params);\n\t\t\tconst { fields, queryString: query, client, joinsNotNullableMap, customResultMapper } = this;\n\t\t\tif (!fields && !customResultMapper) {\n\t\t\t\treturn tracer.startActiveSpan('drizzle.driver.execute', async (span) => {\n\t\t\t\t\tspan?.setAttributes({\n\t\t\t\t\t\t'drizzle.query.text': query,\n\t\t\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t\t\t});\n\n\t\t\t\t\treturn client.querySQL(query, params.length ? params : undefined);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst result = (await tracer.startActiveSpan('drizzle.driver.execute', (span) => {\n\t\t\t\tspan?.setAttributes({\n\t\t\t\t\t'drizzle.query.text': query,\n\t\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t\t});\n\n\t\t\t\treturn client.withSQLRowMode('array').querySQL(query, params.length ? params : undefined);\n\t\t\t})) as unknown[][];\n\n\t\t\treturn tracer.startActiveSpan('drizzle.mapResponse', () => {\n\t\t\t\treturn customResultMapper\n\t\t\t\t\t? (customResultMapper as (rows: unknown[][]) => T['execute'])(result)\n\t\t\t\t\t: result.map((row) => mapResultRow<T['execute']>(fields!, row, joinsNotNullableMap));\n\t\t\t});\n\t\t});\n\t}\n\n\tasync executeRqbV2(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\treturn tracer.startActiveSpan('drizzle.execute', async () => {\n\t\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\t\tthis.logger.logQuery(this.queryString, params);\n\n\t\t\tconst { queryString: query, client, customResultMapper } = this;\n\n\t\t\tconst result = await tracer.startActiveSpan('drizzle.driver.execute', (span) => {\n\t\t\t\tspan?.setAttributes({\n\t\t\t\t\t'drizzle.query.text': query,\n\t\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t\t});\n\n\t\t\t\treturn client.querySQL(query, params.length ? params : undefined);\n\t\t\t});\n\n\t\t\treturn tracer.startActiveSpan('drizzle.mapResponse', () => {\n\t\t\t\treturn (customResultMapper as (rows: Record<string, unknown>[]) => T['execute'])(\n\t\t\t\t\tresult as Record<string, unknown>[],\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\tall(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['all']> {\n\t\treturn tracer.startActiveSpan('drizzle.execute', () => {\n\t\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\t\t\tthis.logger.logQuery(this.queryString, params);\n\t\t\treturn tracer.startActiveSpan('drizzle.driver.execute', (span) => {\n\t\t\t\tspan?.setAttributes({\n\t\t\t\t\t'drizzle.query.text': this.queryString,\n\t\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t\t});\n\t\t\t\treturn this.client.withSQLRowMode('array').querySQL(this.queryString, params.length ? params : undefined).then((\n\t\t\t\t\tresult,\n\t\t\t\t) => result);\n\t\t\t});\n\t\t});\n\t}\n\n\t/** @internal */\n\tisResponseInArrayMode(): boolean {\n\t\treturn this._isResponseInArrayMode;\n\t}\n}\n\nexport interface GelSessionOptions {\n\tlogger?: Logger;\n}\n\nexport class GelDbSession<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTTablesConfig extends TablesRelationalConfig,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends GelSession<GelQueryResultHKT, TFullSchema, TRelations, TTablesConfig, TSchema> {\n\tstatic override readonly [entityKind]: string = 'GelDbSession';\n\n\tprivate logger: Logger;\n\n\tconstructor(\n\t\tprivate client: GelClient,\n\t\tdialect: GelDialect,\n\t\tprivate relations: AnyRelations | undefined,\n\t\tprivate schema: V1.RelationalSchemaConfig<TSchema> | undefined,\n\t\tprivate options: GelSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tisResponseInArrayMode: boolean,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t): GelDbPreparedQuery<T> {\n\t\treturn new GelDbPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tisResponseInArrayMode,\n\t\t\tcustomResultMapper,\n\t\t);\n\t}\n\n\tprepareRelationalQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper?: (rows: Record<string, unknown>[]) => T['execute'],\n\t): GelDbPreparedQuery<T, true> {\n\t\treturn new GelDbPreparedQuery(\n\t\t\tthis.client,\n\t\t\tquery.sql,\n\t\t\tquery.params,\n\t\t\tthis.logger,\n\t\t\tfields,\n\t\t\tfalse,\n\t\t\tcustomResultMapper,\n\t\t\tundefined,\n\t\t\ttrue,\n\t\t);\n\t}\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: GelTransaction<GelQueryResultHKT, TFullSchema, TRelations, TTablesConfig, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\treturn await (this.client as Client).transaction(async (clientTx) => {\n\t\t\tconst session = new GelDbSession(clientTx, this.dialect, this.relations, this.schema, this.options);\n\t\t\tconst tx = new GelDbTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>(\n\t\t\t\tthis.dialect,\n\t\t\t\tsession,\n\t\t\t\tthis.relations,\n\t\t\t\tthis.schema,\n\t\t\t);\n\t\t\treturn await transaction(tx);\n\t\t});\n\t}\n\n\toverride async count(sql: SQL): Promise<number> {\n\t\tconst res = await this.execute<[{ count: string }]>(sql);\n\t\treturn Number(res[0]['count']);\n\t}\n}\n\nexport class GelDbTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTRelations extends AnyRelations,\n\tTTablesConfig extends TablesRelationalConfig,\n\tTSchema extends V1.TablesRelationalConfig,\n> extends GelTransaction<GelQueryResultHKT, TFullSchema, TRelations, TTablesConfig, TSchema> {\n\tstatic override readonly [entityKind]: string = 'GelDbTransaction';\n\n\toverride async transaction<T>(\n\t\ttransaction: (tx: GelDbTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\tconst tx = new GelDbTransaction<TFullSchema, TRelations, TTablesConfig, TSchema>(\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tthis.relations,\n\t\t\tthis.schema,\n\t\t);\n\t\treturn await transaction(tx);\n\t}\n}\n\n// TODO fix this\nexport interface GelQueryResultHKT {\n\treadonly $brand: 'GelQueryResultHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n"],"mappings":"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","names":[]}