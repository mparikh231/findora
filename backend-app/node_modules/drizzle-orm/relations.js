import { getTableUniqueName, IsAlias, OriginalName, Schema, Table } from "./table.js";
import { Columns } from "./table.js";
import { aliasedTable } from "./alias.js";
import { Column } from "./column.js";
import { entityKind, is } from "./entity.js";
import { DrizzleError } from "./errors.js";
import {
  and,
  asc,
  between,
  desc,
  eq,
  exists,
  gt,
  gte,
  ilike,
  inArray,
  isNotNull,
  isNull,
  like,
  lt,
  lte,
  ne,
  not,
  notBetween,
  notExists,
  notIlike,
  notInArray,
  notLike,
  or
} from "./sql/expressions/index.js";
import { Placeholder, SQL, sql, View } from "./sql/sql.js";
class Relations {
  constructor(schema, tables, config) {
    this.schema = schema;
    this.tables = tables;
    this.config = config;
    for (const [tsName, table] of Object.entries(tables)) {
      if (config[tsName]?.$drizzleTypeError)
        continue;
      const isTable = is(table, Table);
      const isView = is(table, View);
      if (!(isTable || isView))
        continue;
      this.tableNamesMap[getTableUniqueName(table)] = tsName;
      this.tablesConfig[tsName] = {
        table,
        tsName,
        dbName: table[Table.Symbol.Name],
        schema: table[Table.Symbol.Schema],
        columns: table[Table.Symbol.Columns],
        relations: config[tsName] || {}
      };
    }
    for (const tableConfig of Object.values(this.tablesConfig)) {
      for (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {
        if (!is(relation, Relation)) {
          continue;
        }
        relation.sourceTable = tableConfig.table;
        relation.fieldName = relationFieldName;
      }
    }
    for (const tableConfig of Object.values(this.tablesConfig)) {
      for (const [relationFieldName, relation] of Object.entries(tableConfig.relations)) {
        if (!is(relation, Relation)) {
          continue;
        }
        const relationPrintName = `relations -> ${tableConfig.tsName}: { ${relationFieldName}: r.${is(relation, One) ? "one" : "many"}.${this.tableNamesMap[getTableUniqueName(relation.targetTable)]}(...) }`;
        if (typeof relation.alias === "string" && !relation.alias) {
          throw new Error(`${relationPrintName}: "alias" cannot be an empty string - omit it if you don't need it`);
        }
        if (relation.sourceColumns?.length === 0) {
          throw new Error(`${relationPrintName}: "from" cannot be an empty array`);
        }
        if (relation.targetColumns?.length === 0) {
          throw new Error(`${relationPrintName}: "to" cannot be an empty array`);
        }
        if (relation.sourceColumns && relation.targetColumns) {
          if (relation.sourceColumns.length !== relation.targetColumns.length && !relation.throughTable) {
            throw new Error(
              `${relationPrintName}: "from" and "to" fields without "through" must have the same length`
            );
          }
          if (relation.through) {
            if (relation.through.source.length !== relation.sourceColumns.length || relation.through.target.length !== relation.targetColumns.length) {
              throw new Error(
                `${relationPrintName}: ".through(column)" must be used either on all columns in "from" and "to" or not defined on any of them`
              );
            }
            for (const column of relation.through.source) {
              if (tables[column._.tableName] !== relation.throughTable) {
                throw new Error(
                  `${relationPrintName}: ".through(column)" must be used on the same table by all columns of the relation`
                );
              }
            }
            for (const column of relation.through.target) {
              if (tables[column._.tableName] !== relation.throughTable) {
                throw new Error(
                  `${relationPrintName}: ".through(column)" must be used on the same table by all columns of the relation`
                );
              }
            }
          }
          continue;
        }
        if (relation.sourceColumns || relation.targetColumns) {
          throw new Error(
            `${relationPrintName}: relation must have either both "from" and "to" defined, or none of them`
          );
        }
        let reverseRelation;
        const targetTableTsName = this.tableNamesMap[getTableUniqueName(relation.targetTable)];
        if (!targetTableTsName) {
          throw new Error(
            `Table "${getTableUniqueName(relation.targetTable)}" not found in provided TS schema`
          );
        }
        const reverseTableConfig = this.tablesConfig[targetTableTsName];
        if (!reverseTableConfig) {
          throw new Error(
            `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and no reverse relations of table "${targetTableTsName}" were found"`
          );
        }
        if (relation.alias) {
          const reverseRelations = Object.values(reverseTableConfig.relations).filter(
            (it) => is(it, Relation) && it.alias === relation.alias && it !== relation
          );
          if (reverseRelations.length > 1) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and multiple relations with alias "${relation.alias}" found in table "${targetTableTsName}": ${reverseRelations.map((it) => `"${it.fieldName}"`).join(", ")}`
            );
          }
          reverseRelation = reverseRelations[0];
          if (!reverseRelation) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and there is no reverse relation of table "${targetTableTsName}" with alias "${relation.alias}"`
            );
          }
        } else {
          const reverseRelations = Object.values(reverseTableConfig.relations).filter(
            (it) => is(it, Relation) && it.targetTable === relation.sourceTable && !it.alias && it !== relation
          );
          if (reverseRelations.length > 1) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and multiple relations between "${targetTableTsName}" and "${this.tableNamesMap[getTableUniqueName(relation.sourceTable)] ?? getTableUniqueName(relation.sourceTable)}" were found.
Hint: you can specify "alias" on both sides of the relation with the same value`
            );
          }
          reverseRelation = reverseRelations[0];
          if (!reverseRelation) {
            throw new Error(
              `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and no reverse relation of table "${targetTableTsName}" with target table "${this.tableNamesMap[getTableUniqueName(relation.sourceTable)] ?? getTableUniqueName(relation.sourceTable)}" was found`
            );
          }
        }
        if (!reverseRelation.sourceColumns || !reverseRelation.targetColumns) {
          throw new Error(
            `${relationPrintName}: not enough data provided to build the relation - "from"/"to" are not defined, and reverse relation "${targetTableTsName}.${reverseRelation.fieldName}" does not have "from"/"to" defined`
          );
        }
        relation.sourceColumns = reverseRelation.targetColumns;
        relation.targetColumns = reverseRelation.sourceColumns;
        relation.through = reverseRelation.through ? {
          source: reverseRelation.through.target,
          target: reverseRelation.through.source
        } : void 0;
        relation.throughTable = reverseRelation.throughTable;
        relation.isReversed = !relation.where;
        relation.where = relation.where ?? reverseRelation.where;
      }
    }
  }
  static [entityKind] = "RelationsV2";
  /** table DB name -> schema table key */
  tableNamesMap = {};
  tablesConfig = {};
}
class Relation {
  constructor(targetTable) {
    this.targetTable = targetTable;
  }
  static [entityKind] = "RelationV2";
  fieldName;
  sourceColumns;
  targetColumns;
  alias;
  where;
  sourceTable;
  through;
  throughTable;
  isReversed;
}
class One extends Relation {
  static [entityKind] = "OneV2";
  optional;
  constructor(tables, targetTable, config) {
    super(targetTable);
    this.alias = config?.alias;
    this.where = config?.where;
    if (config?.from) {
      this.sourceColumns = (Array.isArray(config.from) ? config.from : [config.from]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (config?.to) {
      this.targetColumns = (Array.isArray(config.to) ? config.to : [config.to]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (this.throughTable) {
      this.through = {
        source: (Array.isArray(config?.from) ? config.from : [config.from]).map((c) => c._.through),
        target: (Array.isArray(config?.to) ? config.to : [config.to]).map((c) => c._.through)
      };
    }
    this.optional = config?.optional ?? true;
  }
}
class Many extends Relation {
  constructor(tables, targetTable, config) {
    super(targetTable);
    this.config = config;
    this.alias = config?.alias;
    this.where = config?.where;
    if (config?.from) {
      this.sourceColumns = (Array.isArray(config.from) ? config.from : [config.from]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (config?.to) {
      this.targetColumns = (Array.isArray(config.to) ? config.to : [config.to]).map((it) => {
        this.throughTable ??= it._.through ? tables[it._.through._.tableName] : void 0;
        return it._.column;
      });
    }
    if (this.throughTable) {
      this.through = {
        source: (Array.isArray(config?.from) ? config.from : [config.from]).map((c) => c._.through),
        target: (Array.isArray(config?.to) ? config.to : [config.to]).map((c) => c._.through)
      };
    }
  }
  static [entityKind] = "ManyV2";
}
class AggregatedField {
  static [entityKind] = "AggregatedField";
  table;
  onTable(table) {
    this.table = table;
    return this;
  }
}
class Count extends AggregatedField {
  static [entityKind] = "AggregatedFieldCount";
  query;
  getSQL() {
    if (!this.query) {
      if (!this.table)
        throw new Error("Table must be set before building aggregate field");
      this.query = sql`select count(*) as ${sql.identifier("r")} from ${getTableAsAliasSQL(this.table)}`.mapWith(Number);
    }
    return this.query;
  }
}
const operators = {
  and,
  between,
  eq,
  exists,
  gt,
  gte,
  ilike,
  inArray,
  isNull,
  isNotNull,
  like,
  lt,
  lte,
  ne,
  not,
  notBetween,
  notExists,
  notLike,
  notIlike,
  notInArray,
  or,
  sql
};
const orderByOperators = {
  sql,
  asc,
  desc
};
function getOrderByOperators() {
  return orderByOperators;
}
function mapRelationalRow(row, buildQueryResultSelection, mapColumnValue = (value) => value, parseJson = false, path) {
  for (const selectionItem of buildQueryResultSelection) {
    if (selectionItem.selection) {
      const currentPath = `${path ? `${path}.` : ""}${selectionItem.key}`;
      if (row[selectionItem.key] === null)
        continue;
      if (parseJson)
        row[selectionItem.key] = JSON.parse(row[selectionItem.key]);
      if (selectionItem.isArray) {
        for (const item of row[selectionItem.key]) {
          mapRelationalRow(
            item,
            selectionItem.selection,
            mapColumnValue,
            false,
            currentPath
          );
        }
        continue;
      }
      mapRelationalRow(
        row[selectionItem.key],
        selectionItem.selection,
        mapColumnValue,
        false,
        currentPath
      );
      continue;
    }
    const field = selectionItem.field;
    const value = mapColumnValue(row[selectionItem.key]);
    if (value === null)
      continue;
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else if (is(field, SQL.Aliased)) {
      decoder = field.sql.decoder;
    } else {
      decoder = field.getSQL().decoder;
    }
    row[selectionItem.key] = decoder.mapFromDriverValue(value);
  }
  return row;
}
class RelationsBuilderTable {
  static [entityKind] = "RelationsBuilderTable";
  _;
  constructor(table, key) {
    this._ = {
      name: key,
      table
    };
  }
}
class RelationsBuilderColumn {
  static [entityKind] = "RelationsBuilderColumn";
  _;
  constructor(column, tableName, key) {
    this._ = {
      tableName,
      data: void 0,
      column,
      key
    };
  }
  through(column) {
    return new RelationsBuilderJunctionColumn(
      this._.column,
      this._.tableName,
      this._.key,
      column
    );
  }
}
class RelationsBuilderJunctionColumn {
  static [entityKind] = "RelationsBuilderColumn";
  _;
  constructor(column, tableName, key, through) {
    this._ = {
      tableName,
      data: void 0,
      column,
      through,
      key
    };
  }
}
class RelationsHelperStatic {
  static [entityKind] = "RelationsHelperStatic";
  _;
  constructor(tables) {
    this._ = {
      tables
    };
    const one = {};
    const many = {};
    for (const [tableName, table] of Object.entries(tables)) {
      one[tableName] = (config) => {
        return new One(tables, table, config);
      };
      many[tableName] = (config) => {
        return new Many(tables, table, config);
      };
    }
    this.one = one;
    this.many = many;
  }
  one;
  many;
  /** @internal - to be reworked */
  aggs = {
    count() {
      return new Count();
    }
  };
}
function createRelationsHelper(schema) {
  const schemaTables = Object.fromEntries(
    Object.entries(schema).filter((e) => is(e[1], Table) || is(e[1], View))
  );
  const helperStatic = new RelationsHelperStatic(schemaTables);
  const tables = Object.entries(schema).reduce((acc, [tKey, value]) => {
    if (is(value, Table) || is(value, View)) {
      const rTable = new RelationsBuilderTable(value, tKey);
      const columns = Object.entries(value[Columns]).reduce(
        (acc2, [cKey, column]) => {
          const rbColumn = new RelationsBuilderColumn(column, tKey, cKey);
          acc2[cKey] = rbColumn;
          return acc2;
        },
        {}
      );
      acc[tKey] = Object.assign(rTable, columns);
    }
    return acc;
  }, {});
  return Object.assign(helperStatic, tables);
}
function defineRelations(schema, relations) {
  return new Relations(
    schema,
    schema,
    relations ? relations(createRelationsHelper(schema)) : {}
  );
}
function fieldSelectionToSQL(table, target) {
  const field = table[Columns][target];
  return field ? is(field, Column) ? field : is(field, SQL.Aliased) ? sql`${table}.${sql.identifier(field.fieldAlias)}` : sql`${table}.${sql.identifier(target)}` : sql`${table}.${sql.identifier(target)}`;
}
function relationsFieldFilterToSQL(column, filter) {
  if (typeof filter !== "object" || is(filter, Placeholder))
    return eq(column, filter);
  const entries = Object.entries(filter);
  if (!entries.length)
    return void 0;
  const parts = [];
  for (const [target, value] of entries) {
    if (value === void 0)
      continue;
    switch (target) {
      case "NOT": {
        const res = relationsFieldFilterToSQL(column, value);
        if (!res)
          continue;
        parts.push(not(res));
        continue;
      }
      case "OR": {
        if (!value.length)
          continue;
        parts.push(
          or(
            ...value.map((subFilter) => relationsFieldFilterToSQL(column, subFilter))
          )
        );
        continue;
      }
      case "AND": {
        if (!value.length)
          continue;
        parts.push(
          and(
            ...value.map((subFilter) => relationsFieldFilterToSQL(column, subFilter))
          )
        );
        continue;
      }
      case "isNotNull":
      case "isNull": {
        if (!value)
          continue;
        parts.push(operators[target](column));
        continue;
      }
      case "in": {
        parts.push(operators.inArray(column, value));
        continue;
      }
      case "notIn": {
        parts.push(operators.notInArray(column, value));
        continue;
      }
      default: {
        parts.push(
          operators[target](
            column,
            value
          )
        );
        continue;
      }
    }
  }
  if (!parts.length)
    return void 0;
  return and(...parts);
}
function relationsFilterToSQL(table, filter, tableRelations = {}, tablesRelations = {}, tableNamesMap = {}, casing, depth = 0) {
  const entries = Object.entries(filter);
  if (!entries.length)
    return void 0;
  const parts = [];
  for (const [target, value] of entries) {
    if (value === void 0)
      continue;
    switch (target) {
      case "RAW": {
        const processed = typeof value === "function" ? value(table, operators) : value.getSQL();
        parts.push(processed);
        continue;
      }
      case "OR": {
        if (!value?.length)
          continue;
        parts.push(
          or(
            ...value.map(
              (subFilter) => relationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, tableNamesMap, casing, depth)
            )
          )
        );
        continue;
      }
      case "AND": {
        if (!value?.length)
          continue;
        parts.push(
          and(
            ...value.map(
              (subFilter) => relationsFilterToSQL(table, subFilter, tableRelations, tablesRelations, tableNamesMap, casing, depth)
            )
          )
        );
        continue;
      }
      case "NOT": {
        if (value === void 0)
          continue;
        const built = relationsFilterToSQL(
          table,
          value,
          tableRelations,
          tablesRelations,
          tableNamesMap,
          casing,
          depth
        );
        if (!built)
          continue;
        parts.push(not(built));
        continue;
      }
      default: {
        if (table[Columns][target]) {
          const column = fieldSelectionToSQL(table, target);
          const colFilter = relationsFieldFilterToSQL(
            column,
            value
          );
          if (colFilter)
            parts.push(colFilter);
          continue;
        }
        const relation = tableRelations[target];
        if (!relation) {
          throw new DrizzleError({
            message: `Unknown relational filter field: "${target}"`
          });
        }
        const targetTable = aliasedTable(relation.targetTable, `f${depth}`);
        const throughTable = relation.throughTable ? aliasedTable(relation.throughTable, `ft${depth}`) : void 0;
        const targetConfig = tablesRelations[tableNamesMap[getTableUniqueName(relation.targetTable)]];
        const {
          filter: relationFilter,
          joinCondition
        } = relationToSQL(casing, relation, table, targetTable, throughTable);
        const subfilter = typeof value === "boolean" ? void 0 : relationsFilterToSQL(
          targetTable,
          value,
          targetConfig.relations,
          tablesRelations,
          tableNamesMap,
          casing,
          depth + 1
        );
        const filter2 = and(
          relationFilter,
          subfilter
        );
        const subquery = throughTable ? sql`(select * from ${getTableAsAliasSQL(targetTable)} inner join ${getTableAsAliasSQL(throughTable)} on ${joinCondition}${sql` where ${filter2}`.if(filter2)} limit 1)` : sql`(select * from ${getTableAsAliasSQL(targetTable)}${sql` where ${filter2}`.if(filter2)} limit 1)`;
        if (filter2)
          parts.push((value ? exists : notExists)(subquery));
      }
    }
  }
  return and(...parts);
}
function relationsOrderToSQL(table, orders) {
  if (typeof orders === "function") {
    const data = orders(table, orderByOperators);
    return is(data, SQL) ? data : Array.isArray(data) ? data.length ? sql.join(data.map((o) => is(o, SQL) ? o : asc(o)), sql`, `) : void 0 : is(data, Column) ? asc(data) : void 0;
  }
  const entries = Object.entries(orders).filter(([_, value]) => value);
  if (!entries.length)
    return void 0;
  return sql.join(
    entries.map(([target, value]) => (value === "asc" ? asc : desc)(fieldSelectionToSQL(table, target))),
    sql`, `
  );
}
function relationExtrasToSQL(table, extras) {
  const subqueries = [];
  const selection = [];
  for (const [key, field] of Object.entries(extras)) {
    if (!field)
      continue;
    const extra = typeof field === "function" ? field(table, { sql: operators.sql }) : field;
    const query = sql`(${extra.getSQL()}) as ${sql.identifier(key)}`;
    query.decoder = extra.getSQL().decoder;
    subqueries.push(query);
    selection.push({
      key,
      field: query
    });
  }
  return {
    sql: subqueries.length ? sql.join(subqueries, sql`, `) : void 0,
    selection
  };
}
function relationToSQL(casing, relation, sourceTable, targetTable, throughTable) {
  if (relation.through) {
    const outerColumnWhere = relation.sourceColumns.map((s, i) => {
      const t = relation.through.source[i];
      return eq(
        sql`${sourceTable}.${sql.identifier(casing.getColumnCasing(s))}`,
        sql`${throughTable}.${sql.identifier(is(t._.column, Column) ? casing.getColumnCasing(t._.column) : t._.key)}`
      );
    });
    const innerColumnWhere = relation.targetColumns.map((s, i) => {
      const t = relation.through.target[i];
      return eq(
        sql`${throughTable}.${sql.identifier(is(t._.column, Column) ? casing.getColumnCasing(t._.column) : t._.key)}`,
        sql`${targetTable}.${sql.identifier(casing.getColumnCasing(s))}`
      );
    });
    return {
      filter: and(
        relation.where ? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where) : void 0,
        ...outerColumnWhere
      ),
      joinCondition: and(...innerColumnWhere)
    };
  }
  const columnWhere = relation.sourceColumns.map((s, i) => {
    const t = relation.targetColumns[i];
    return eq(
      sql`${sourceTable}.${sql.identifier(casing.getColumnCasing(s))}`,
      sql`${targetTable}.${sql.identifier(casing.getColumnCasing(t))}`
    );
  });
  const fullWhere = and(
    ...columnWhere,
    relation.where ? relationsFilterToSQL(relation.isReversed ? sourceTable : targetTable, relation.where) : void 0
  );
  return { filter: fullWhere };
}
function getTableAsAliasSQL(table) {
  return sql`${table[IsAlias] ? sql`${sql`${sql.identifier(table[Schema] ?? "")}.`.if(table[Schema])}${sql.identifier(table[OriginalName])} as ${table}` : table}`;
}
export {
  AggregatedField,
  Count,
  Many,
  One,
  Relation,
  Relations,
  RelationsBuilderColumn,
  RelationsBuilderJunctionColumn,
  RelationsBuilderTable,
  RelationsHelperStatic,
  createRelationsHelper,
  defineRelations,
  fieldSelectionToSQL,
  getOrderByOperators,
  getTableAsAliasSQL,
  mapRelationalRow,
  operators,
  orderByOperators,
  relationExtrasToSQL,
  relationToSQL,
  relationsFilterToSQL,
  relationsOrderToSQL
};
//# sourceMappingURL=relations.js.map